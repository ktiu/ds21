[["index.html", "Data Science für die Humangeographie: Ein pragmatischer Einstieg mit R Konzeption quantitativer Forschung Terminüberblick", " Data Science für die Humangeographie: Ein pragmatischer Einstieg mit R Konzeption quantitativer Forschung Till Straube Institut für Humangeographie Goethe-Universität Frankfurtstraube@geo.uni-frankfurt.de Winter- und Sommersemester 2020/21 Terminüberblick Alle Sitzungen finden von 13 bis 16h c.t. statt Datum Sitzung Inhalt 2. November 2020 1 Vorbesprechung 9. November 2020 2 Erste Schritte 16. November 2020 3 Text: Anderson 2008 23. November 2020 4 Datenstrukturen 30. November 2020 5 Visualisierungen 7. Dezember 2020 6 Text: Shelton et al. 2014 14. Dezember 2020 7 Geodaten 11. Januar 2021 8 Choroplethen 18. Januar 2021 9 Text: Chandra 2014 25. Januar 2021 10 HTML-Tabellen 1. Februar 2021 11 Web scraping 8. Februar 2021 12 Text: Straube 2021 15. Februar 2021 13 Präsentationen 31. März 2021 Abgabe Exposé 12. April 2021 14 APIs 19. April 2021 15 Serialisierung 26. April 2021 16 Text: Breuer 2005 03. Mai 2021 17 Reguläre Ausdrücke 10. Mai 2021 18 Merging, Grouping 17. Mai 2021 19 Text: Bowker und Star 2003 24. Mai 2021 20 Entfällt (Pfingstmontag) 31. Mai 2021 21 Datenmanagement und Kollaboration 07. Juni 2021 22 Clusteranalyse 14. Juni 2021 23 Text: Beer 2017 21. Juni 2021 24 ANOVA 28. Juni 2021 25 Rmarkdown 05. Juli 2021 26 Präsentationen 12. Juli 2021 27 Präsentationen "],["online-ressourcen.html", "Online-Ressourcen R Tutorials und eBooks Inspiration für Visualisierungen Spezialthemen", " Online-Ressourcen R Tutorials und eBooks R for Data Science https://r4ds.had.co.nz/ Ausführliches Handbuch, Fokus auf Data Science RStudio Cloud Primers https://rstudio.cloud/learn/primers/1 Swirl https://swirlstats.com/students.html Interaktives Tutorial als R-Paket, mit verschiedenen Lektionen Quick-R https://www.statmethods.net/r-tutorial/index.html Überblickartiges Tutorial, kurz und bündig RStudio Cheat Sheets https://www.rstudio.com/resources/cheatsheets/ Einseitige Cheat Sheets zu verschiedenen Themen Google’s R Style Guide https://google.github.io/styleguide/Rguide.xml Regeln für leserlichen R Code Inspiration für Visualisierungen R Graph Gallery https://www.r-graph-gallery.com/ Viele Beispiele für verschiedenste Visualisierungen DDJ Katalog http://katalog.datenjournalismus.net/#/ Portfolio Datenjournalismus, leider etwas veraltet Subreddits https://www.reddit.com/r/dataisbeautiful https://www.reddit.com/r/DataArt/ https://www.reddit.com/r/MapPorn/ Infographics https://www.listendata.com/2019/06/create-infographics-with-r.html HTML Widgets für R http://gallery.htmlwidgets.org/ Spezialthemen HTML-Überblick https://www.tutorialspoint.com/de/html/ Tutorial Reguläre Ausdrücke https://danielfett.de/en/tutorials/tutorial-regulare-ausdrucke/ Deutschsprachige Einführung zu regulären Ausdrücken Übersicht CSS-Selektoren https://www.w3schools.com/cssref/css_selectors.asp "],["vorbesprechung.html", "Sitzung 1 Vorbesprechung 1.1 Überblick 1.2 Seminarformat 1.3 Leistungsnachweise 1.4 Lehrphilosophie", " Sitzung 1 Vorbesprechung 1.1 Überblick 1.1.1 Seminar im Curriculum Dieses Seminar ist Bestandteil des Moduls BA3. Das Projektseminar besteht aus zwei Teilen über zwei Semester: Konzeption quantitativer Forschung (Wintersemester) Analyse quantitativer Daten (Sommersemester) Im Winter gibt es 12 inhaltliche Termine (davon 4x Textarbeit). Im Sommer wird das Seminar mit den selben Teilnehmer*innen fortgeführt. 1.1.2 Lernziele für das Wintersemester Sie können… einfache Skripte in R eigenständig erstellen. Datensätze in vielfältigen Formaten visualisieren. Online-Ressourcen gezielt einsetzen. Möglichkeiten der Datenbeschaffung identifizieren. epistemologische Verschiebungen durch Data Science wiedergeben. 1.1.3 Technische Anforderungen Es sind keine Vorkenntnisse in R erforderlich. Sie brauchen einen Laptop, mit dem Sie gut arbeiten können. Wir benutzen die RStudio Cloud als Plattform. Sie brauchen einen ruhigen Arbeitsplatz. 1.1.4 Unterstützung im Corona-Semester Die Uni bietet einen Semesterlaptop an. Bei Bedarf kann ich gerne versuchen, Arbeitsplätze im Seminarraum (PEG) anzubieten. Bitte kontaktieren Sie mich per E-Mail, falls Sie einen Arbeitsplatz regelmäßig in Anspruch nehmen wollen würden. 1.2 Seminarformat Das Seminar findet jede Woche Montags, 13–16h c.t. statt. Der Zoom-Link, den Sie per E-Mail erhalten haben, bleibt gleich. Wir machen um ca. 14:25h eine zehnminütige Pause. Für Textbesprechungen wird die Gruppe zweigeteilt. Dieses Seminar findet in verschiedenen Modi statt: 1.2.1 Input und Plenum Ich rede oder moderiere (mit Folien oder ohne) Sie hören mir und Ihren Kommiliton*innen aufmerksam zu Sie melden sich für Redebeiträge oder Fragen (Zoom-Funktion) Die*der Chat-Verantwortliche unterbricht mich bei Klärungsbedarf 1.2.2 Think-pair-share Sie bearbeiten eine Fragestellung in zufälligen Zweier-Konstellationen (Breakout-Session) Nach einer vorgegebenen Zeitspanne kehren Sie ins Plenum zurück Ich fordere Sie ggf. auf, Ergebnisse und offene Fragen mit der Gruppe zu teilen 1.2.3 Follow the recipe Ich teile ein unvollständiges Beispielprojekt. Wir gehen die Teilschritte nach und nach durch. Ich habe den Plan, stelle aber immer wieder Fragen ans Plenum. Sie vollziehen die Schritte an Ihrer eigenen Kopie des Projekts nach. Die*der Chat-Verantwortliche unterbricht mich bei Klärungsbedarf 1.2.4 Hands-on session Sie bearbeiten praktische Aufgabenstellungen alleine. Dabei sind sie in zufälligen Dreier-Konstellationen (Breakout-Session). Bei Fragen oder Problemen wenden Sie sich zunächst an Ihre Kleingruppe. Falls Sie nicht weiterkommen, fordern Sie Hilfe an (Zoom-Funktion). Ich reagiere auf Hilfegesuche oder schaue in zufälligen Gruppen vorbei. 1.2.5 Share your work Ich wähle eine Teilnehmer*in zufällig aus. Die Person teilt ihren Bildschirm und berichtet von ihrer Bearbeitung eines Problems. Alle anderen unterstützen solidarisch durch aktives Nachvollziehen, Nachfragen und Hinweise. 1.3 Leistungsnachweise 1.3.1 Exposé (WiSe) Zum Ende des Wintersemesters geben Sie ein Exposé für ein Untersuchungsvorhaben für das Sommersemester ab. Sie können sich mit bis zu vier Personen zusammenschließen. Die Projektgruppe besteht dann verbindlich für das Sommersemester. Damit steigen aber auch die Anforderungen an Umfang, Detail und technischen Anspruch. Umfang für das Exposé: max. 15k Zeichen inkl. Leerzeichen, exkl. Literaturverzeichnis Als Abgabetermin haben wir den 31. März vereinbart. 1.3.1.1 Inhalte Einführung ins Thema Forschungsstand / Literaturüberblick Herleitung einer klar abgegrenzten (vorläufigen) Forschungsfrage Konkrete Datenquellen Ideen für Verfahren und Visualisierungen 1.3.1.2 Bewertungskriterien Alle Kriterien werden mit einer (runden) Schulnote bewertet. Der gewichtete Schnitt ergibt die Gesamtnote. Kriterium Gewichtung Erläuterung Ziterweise und Formatierung 10% Der Text erfüllt formale Anforderungen an Wissenschaftlichkeit. Ausdruck und Rechtschreibung 10% Der Text ist sprachlich gelungen. Roter Faden 10% Der Text ist übersichtlich strukturiert und die Einzelteile greifen gut ineinander. Literatur 10% Die zitierten Quellen sind für eine Einführung ins Thema geeignet und werden gut zusammengefasst. Theorie 10% Relevante wissenschaftliche Perspektiven werden anhand von geeigneter Fachliteratur aufgezeigt. Fragestellung 10% Die Forschungsfrage ist für das Vorhaben geeignet und wird überzeugend hergeleitet. Datenquellen 20% Die Datenquellen sind geeignet und detailliert beschrieben. Design 20% Das Untersuchungsvorhaben ist nachvollziehbar beschrieben, und der technische Anspruch ist dem Projektseminar angemessen. 1.3.2 Projektbericht (SoSe) Zum Ende des Sommersemesters geben Sie einen Projektbericht ab. Der Projektbericht darf (überarbeitete) Teile des Exposés enthalten. Die Gruppen, in denen Sie Ihr Exposé verfasst haben, bleiben verbindlich bestehen. Umfang für den Projektbericht: max. 35k Zeichen inkl. Leerzeichen exkl. Literaturverzeichnis exkl. Code Als Abgabetermin haben wir den 31. August vereinbart. 1.3.2.1 Format Der Projektbericht muss in Rmarkdown verfasst werden und (grundsätzlich) ausführbar sein. Daten, die für die Ausführung benötigt werden, müssen mit abgegeben werden. (Bei sehr großen Datensätzen wenden Sie sich bitte frühzeitig an mich). Dabei dürfen alle Pakete aus CRAN verwendet werden. Eigene Scripts müssen mit abgegeben werden. Aufwändige oder prekäre Zwischenschritte (etwa Web Scraping, rechenintensive Grafiken) bitte als Zwischenergebnis speichern. (Code trotzdem darlegen!) 1.3.2.2 Inhalte Einführung ins Thema Forschungsstand / Literaturüberblick Herleitung einer klar abgegrenzten Forschungsfrage Besprechung der Datenquellen Darstellung der Methoden für Datenbeschaffung Datenaufbereitung (säubern, verschneiden) Datenanalyse (Visualisierung, statische Verfahren) Präsentation der Ergebnisse Einordnung der Ergebnisse 1.3.2.3 Bewertungskriterien Alle Kriterien werden mit einer (runden) Schulnote bewertet. Der gewichtete Schnitt ergibt die Gesamtnote. Kriterium Gewichtung Erläuterung Ziterweise und Formatierung 10% Der Text erfüllt formale Anforderungen an Wissenschaftlichkeit. Ausdruck und Rechtschreibung 10% Der Text ist sprachlich gelungen. Roter Faden 10% Der Text ist übersichtlich strukturiert und die Einzelteile greifen gut ineinander. Literatur 5% Die zitierten Quellen sind für eine Einführung ins Thema geeignet und werden gut zusammengefasst. Theorie 10% Relevante wissenschaftliche Perspektiven werden anhand von geeigneter Fachliteratur aufgezeigt. Fragestellung 5% Die Forschungsfrage ist für das Vorhaben geeignet und wird überzeugend hergeleitet. Anspruch 20% Der technische Anspruch ist dem Projektseminar angemessen. Beschaffung 10% Die Datenquellen sind geeignet und werden nachvollziehbar ausgelesen. Aufbereitung 10% Die Datenaufbereitung ist sauber durchgeführt und gut nachvollziehbar. Analyse 10% Die Datenanalyse ist geeignet, sauber durchgeführt und anschaulich beschrieben. 1.3.3 Anwesenheit Es besteht Anwesenheitspflicht. Für Ihre ersten zwei Fehltermine pro Semester brauche ich keine Entschuldigung (aber Sie sollten das ggf. mit ihrer Projektgruppe absprechen). Sie sind dann selbstständig für die Nacharbeit der behandelten Themen zuständig. Im Falle eines zusätzlichen Fehltermins brauche ich ein Attest und einen Nachweis über Nacharbeit. Zur Anwesenheit gehört… uneingeschränkte Aufmerksamkeit über die komplette Veranstaltungsdauer, aktive Mitarbeit an Beispielen, Bearbeitung von Übungsaufgaben, aktive Beteiligung an Diskussionen. Eine eingeschaltete Kamera macht das allen Beteiligten leichter! 1.4 Lehrphilosophie Die folgenden vier Säulen habe ich mal im Rahmen einer Fortbildung als meine Lehrphilosophie definiert. Sie spiegeln meinen eigenen Anspruch an meine Lehre wider und sind auch als Vorschlag für ein gutes Miteinander zu verstehen. Begreifen Sie die hier genannten Aspekte gerne auch als Ermunterung, sie von mir und Ihren Kommiliton*innen einzufordern, wenn sie in der Veranstaltung zu kurz kommen. 1.4.1 Transparenz Erforderliche Leistungen und Bewertungskriterien sind vorab bekannt. Termine und Regelungen werden in der Vorbereitungssitzung verbindlich vereinbart. Aktuelle Lehrmaterialien stehen online durchgängig zur Verfügung. 1.4.2 Praktische Übungen Eigenständige Anwendung steht im Vordergrund. Verfahren und Techniken werden mit Beispielen und Übungen erarbeitet. Die perfekte Aufgabe ist immer ein bisschen zu schwer. Toleranz für Frustration ist eine wichtige Fähigkeit und lässt sich trainieren. 1.4.3 Geschützte Räume Alle können sich im Plenum respektiert und sicher fühlen. Verletzendes Verhalten wird benannt. Es gibt einen vertrauensvollen Rahmen für ehrlichen Austausch. Frustrationen und Momente des Scheiterns werden ernst genommen und konstruktiv bearbeitet. 1.4.4 Kritische Reflexion Auch Teilnehmende, die kein weiterführendes Interesse an der Anwendung quantitativer Verfahren haben, sind im Seminar gut aufgehoben. Verfahren werden kontextualisiert, ihre Limitationen werden aufgezeigt. Kritische Forschung zu quantitativen Praktiken wird besprochen. "],["erste-schritte.html", "Sitzung 2 Erste Schritte 2.1 Vorbereitung 2.2 Lernziele für diese Sitzung 2.3 Operatoren 2.4 Variablen 2.5 Konstanten 2.6 Funktionen 2.7 Strings 2.8 Datentypen 2.9 Aufgaben", " Sitzung 2 Erste Schritte 2.1 Vorbereitung Machen Sie sich einen kostenlosen Account auf https://rstudio.cloud Treten Sie dem Seminar-Workspace bei. (Sie erhalten eine Einladung per E-Mail.) Optional/alternativ: installieren Sie R und RStudio auf Ihrem Computer. 2.2 Lernziele für diese Sitzung Sie können… Rechenoperatoren einsetzen. Variablen zuweisen. Funktionen aufrufen. Hilfe zu Funktionen anzeigen. die wichtigsten Variablentypen bestimmen. zwischen Variablentypen konvertieren. 2.3 Operatoren Zunächst stellen wir fest, dass man die R-Konsole ganz banal als Taschenrechner benutzen kann: 1 + 4 ## [1] 5 8 / 3 ## [1] 2.666667 (2.45 + 3.5) * 7 ## [1] 41.65 Die Zeichen +, -, * usw. heißen in der Informatik Operatoren oder Infixe (weil sie immer zwischen zwei Werten stehen). 2.4 Variablen Variablen funktionieren so, dass man einem Wert einen Namen gibt. Die Zuweisung folgt dabei dem Schema NAME &lt;- WERT: x &lt;- 5 Nach einer erfolgreichen Variablenzuweisung gibt die Konsole keine Rückmeldung, sondern nur bei Fehlern. x steht jetzt für die Zahl fünf. Mit dieser Variable können wir jetzt genauso rechnen wie mit einer Zahl: x + 3 ## [1] 8 Auch die Zuweisung von Variablen kann Rechenoperationen und andere Variablen enthalten: y &lt;- (x * 2) - 1 print(y) ## [1] 9 Der Befehl print(y) ist dabei ganz einfach die Anweisung an die Konsole, den Wert für y auszugeben. Das passiert zwar auch, wenn man nur y eingibt, aber print(y) (oder print(x), print(1 + 1), usw.) ist die formal korrekte Schreibweise. Der Wert einer Variable kann auch verändert werden. Dafür weisen wir ihr einfach einen neuen Wert zu: x &lt;- 20 print(x) ## [1] 20 Eine Besonderheit ist, dass der alte Wert der Variable auch innerhalb der Zuweisung eines neuen Werts benutzt werden darf. Das kann in einem Script sehr praktisch sein. Wenn wir x also um 0,5 erhöhen wollen, sieht das so aus: x &lt;- x + 0.5 print(x) ## [1] 20.5 Dabei wird als Dezimaltrennzeichen ausschließlich der Punkt verwendet. 2.5 Konstanten Manche benannten Werte sind schon in R eingebaut: print(pi) ## [1] 3.141593 Diese Werte heißen üblicherweise Konstanten – allerdings lassen sie sich in R auch überschreiben! pi &lt;- 3 print(pi) ## [1] 3 2.6 Funktionen Mit print() haben wir schon unsere erste Funktion kennengelernt. R stellt uns eine Vielzahl von verschiedenen Funktionen zur Verfügung, und sie werden immer nach dem gleichen Schema benutzt: FUNKTIONSNAME(PARAMETER). Parameter (auf Englisch auch arguments) sind die Werte, die als Input an die Funktion übergeben werden. Je nach Funktion können das auch mehrere Werte sein, die dann durch Kommas getrennt werden. So nimmt die Funktion max(), die den Maximalwert bestimmt, beliebig viele Zahlen als Parameter: max(1, 2, 2, 5, 4, 3) ## [1] 5 Die Funktion round() hat als optionalen Parameter die Anzahl der Nachkommastellen, auf die gerundet werden soll. Wenn er nicht angegeben wird, nimmmt dieser Parameter immer den Wert 0 an: round(4.567) ## [1] 5 Aber er lässt sich auch spezifizieren: round(4.567, digits = 2) ## [1] 4.57 Dabei sind die folgenden Ausdrücke identisch: round(4.567, digits = 2) ## [1] 4.57 round(4.567, 2) ## [1] 4.57 round(digits = 2, 4.567) ## [1] 4.57 Was Funktionen genau machen und welche Parameter sie dabei nehmen, ist in der R-Dokumentation sehr ausführlich (und auf den ersten Blick recht kompliziert) beschrieben. Ganz am Ende der Hilfeseite finden sich oft Beipsiele. Die Hilfe zu einer Funktion kann mit folgendem Befehl aufgerufen werden: ?max Notiz am Rande: Auch die Infix-Operatoren +, -, *, usw. sind eigentlich nur verkürzte Schreibweisen von Funktionen. Mit backticks ( ` ) lassen sie sich in vollwertige Funktionen zurückverwandeln: `+`(2, 2) ## [1] 4 2.7 Strings R kann nicht nur mit Zahlen umgehen, sondern auch mit Text. Ein String ist eine Aneinanderreihung von Buchstaben, und wird mit einfachen oder doppelten Anführungszeichen umschlossen: print(&quot;Hello, World!&quot;) ## [1] &quot;Hello, World!&quot; Auch Variablen können Strings als Wert haben: name &lt;- &quot;Hase&quot; Es gibt auch Funktionen, die Strings als Parameter nehmen. paste fügt Strings aneinander: paste(&quot;Mein Name ist&quot;, name) ## [1] &quot;Mein Name ist Hase&quot; 2.8 Datentypen Den Typ einer Variable oder eines Wertes bestimmen wir durch den Befehl str(): str(name) ## chr &quot;Hase&quot; str(10) ## num 10 Dabei steht chr („character“) für Strings und num („numeric“) für Zahlen. Ein weiterer Variablentyp ist logi („logical“), der prinzipiell nur die Werte TRUE oder FALSE annehmen kann. Dieser Typ heißt auch Boolsche Variabel: str(FALSE) ## logi FALSE Soweit es ein eindeutiges Ergebnis gibt, kann R mit den entsprechenden Befehlen Werte vom einen in den anderen Typ umwandeln: as.numeric(&quot;1000&quot;) ## [1] 1000 as.character(x) ## [1] &quot;20.5&quot; as.logical(0) ## [1] FALSE Kann R einen Wert nicht umwandeln, dann kommt dabei NA raus (mit einer Warnung): as.numeric(&quot;Hallo!&quot;) ## [1] NA NA („not available/assigned“) ist dabei ein besonderer Wert, den jeder Variablentyp annehmen kann. 2.9 Aufgaben 2.9.1 Rechnen Lösen Sie folgende Rechenaufgaben mit Hilfe von R: 4 plus 10 8 mal 12 4 minus 7 3 hoch 18 4,5 geteilt durch die Summe von 5 und 8 Quadratwurzel aus 101 Kubikwurzel aus 12 2.9.2 Variablen Weisen Sie den Variablen a bis g folgende Werte zu: TRUE 2 Ihren Namen Die Quadratwurzel aus b 8 \\(\\textstyle\\frac{1}{4}\\) Das vierfache von e Die aktuelle Uhrzeit mit Datum und Zeitzone (automatisch generiert) 2.9.3 Datentypen Bestimmen Sie die Typen der Variablen a bis g. Finden Sie je zwei Beispiele für die Umwandlung… von numeric zu character von numeric zu logical von character zu logical von character zu numeric von logical zu character von logical zu numeric von character zu Date von Date zu numeric (Date ist kein eigentlicher Datentyp, aber erfüllt an dieser Stelle denselben Zweck.) 2.9.4 Swirl Folgen Sie den Anleitungen, um Swirl zu installieren: https://swirlstats.com/students.html Absolvieren Sie Lektion 1 („Basic Building Blocks“). 2.9.5 Recherche Recherchieren Sie: Welche Funktion gibt den absoluten Wert einer Zahl aus? (z.B. -4 ergibt 4, 8 ergibt 8) Welche Konstanten sind in R „eingebaut“? Wie bestimmt man den „Rest“ einer Division? (z.B. 40 geteilt durch 7 hat den Rest 5) In der Statistik wird zwischen stetigen und diskreten Variablen unterschieden. Welche äquivalente Unterscheidung nimmt R vor? 2.9.6 Kniffliges Lösen Sie die folgenden Probleme: Durch welchen Ausdruck lässt sich eine Zahl auf die nächste gerade Zahl runden? (z.B. 18,9 auf 18,0 oder 21,2 auf 22,0) Durch welchen Ausdruck lässt sich eine Zahl auf die nächste halbe Zahl abrunden? (z.B. 18,9 auf 18,5 oder 21,2 auf 21,0) Absolvieren Sie in die Lektion 8 („Logic“). Machen Sie sich mit der Funktion xor() vertraut. Finden Sie einen Ausdruck, der xor() simuliert, aber nur aus Infix-Operatoren besteht. Was bedeutet „strong“ bzw „weak typing“? Wie ist R hier einzuordnen? Was sind funktionale Programmiersprachen? Welche Eigenschaften von R sind funktional, welche nicht? Starten Sie den R Track in Excercism Richten Sie sich ein IDE außer RStudio für einen R Workflow ein. "],["text-anderson-2008.html", "Sitzung 3 Text: Anderson 2008 3.1 Lesetext 3.2 Fragen an den Text", " Sitzung 3 Text: Anderson 2008 3.1 Lesetext Anderson, Chris. 2008. The End of Theory: The Data Deluge Makes the Scientific Method Obsolete. URL: https://www.wired.com/2008/06/pb-theory/ (zugegriffen: 11. Juli 2017). 3.2 Fragen an den Text Um welche Art von Text handelt es sich? Wer ist der Autor, und an wen wendet er sich? Was ist das zentrale Anliegen des Texts? Welche Entwicklungen werden beschrieben? Mit welchen Begriffen würden wir diese Phänomene heute beschreiben? Aus heutiger Perspektive: Hatte der Autor recht? Warum / warum nicht? In welchen Punkten stimmen Sie dem Autor zu? Wie würden Sie den Text problematisieren? "],["datenstrukturen.html", "Sitzung 4 Datenstrukturen 4.1 Lernziele dieser Sitzung 4.2 Vektoren 4.3 Matritzen 4.4 Listen 4.5 Data Frames 4.6 Tibbles 4.7 Aufgaben", " Sitzung 4 Datenstrukturen 4.1 Lernziele dieser Sitzung Sie können… die verschiedenen Strukturen für Datensätze in R benennen. Vektoren generieren. einfache Befehle mit Vektoren durchführen. Beispieldatensätze aufrufen und beschreiben. 4.2 Vektoren Vektoren (engl. vectors) sind eindimensionale Reihen von Werten gleichen Typs. Sie bilden einen wichtigen Baustein von R und von den hier im Seminar besprochenen Inhalten. Sie können manuell mit der Funktion c(...) erstellt werden und wie Variablen benannt werden: alter &lt;- c(39, 49, 63, 44, 40) alter ## [1] 39 49 63 44 40 Es gibt darüber hinaus aber auch Möglichkeiten, Vektoren automatisch zu generieren: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 seq(100, 10, by=-10) ## [1] 100 90 80 70 60 50 40 30 20 10 Buchstaben sind als Vektor in R eingebaut: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; ## [13] &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; ## [25] &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; ## [13] &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; ## [25] &quot;Y&quot; &quot;Z&quot; Manche Funktionen sind speziell für Vektoren gedacht: rev(1:10) ## [1] 10 9 8 7 6 5 4 3 2 1 Andere Funktionen, die für einzelne Werte gedacht sind, werden für jeden Wert einzeln ausgeführt: toupper(&quot;hallo&quot;) ## [1] &quot;HALLO&quot; toupper(c(&quot;ein&quot;, &quot;paar&quot;, &quot;strings&quot;)) ## [1] &quot;EIN&quot; &quot;PAAR&quot; &quot;STRINGS&quot; Elemente von Vektoren können mit eckigen Klammern einzeln oder selektiv angesprochen bzw entfernt werden: letters[2] ## [1] &quot;b&quot; letters[2:3] ## [1] &quot;b&quot; &quot;c&quot; letters[-2] ## [1] &quot;a&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; ## [13] &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; ## [25] &quot;z&quot; Vektoren können wie Variablen benutzt werden: 2018 - alter ## [1] 1979 1969 1955 1974 1978 paste(alter, &quot;ist ein gutes Alter&quot;) ## [1] &quot;39 ist ein gutes Alter&quot; &quot;49 ist ein gutes Alter&quot; ## [3] &quot;63 ist ein gutes Alter&quot; &quot;44 ist ein gutes Alter&quot; ## [5] &quot;40 ist ein gutes Alter&quot; length(x) gibt die Anzahl der Elemente in einem Vektor x aus: length(alter) ## [1] 5 Von Verteilungen, die als Vektoren vorliegen, lassen sich statistische Parameter einfach errechnen: mean(alter) ## [1] 47 median(alter) ## [1] 44 sd(alter) ## [1] 9.77241 IQR(alter) ## [1] 9 (Aber IQR() berechnet anders als in der Vorlesung besprochen!) Wir können den Mittelwert auch mit Hilfe der sum() und length() Funktionen selbst berechnen: sum(alter) / length(alter) ## [1] 47 4.3 Matritzen Matritzen (engl. matrix) sind zweidimensionale Reihen von Werten gleichen Typs. matrix(1:15, nrow=3) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 4 7 10 13 ## [2,] 2 5 8 11 14 ## [3,] 3 6 9 12 15 Sie spielen in diesem Seminar aber keine große Rolle. 4.4 Listen Listen sind eindimensionale Reihen von Werten, wobei der Typ egal ist: list(&quot;Hallo&quot;, 10, F) ## [[1]] ## [1] &quot;Hallo&quot; ## ## [[2]] ## [1] 10 ## ## [[3]] ## [1] FALSE Dabei können die Werte benannt sein, und Listen können Unterlisten enthalten: profil &lt;- list(name=&quot;Till&quot;, plz=60326, x=list(TRUE, TRUE, FALSE)) str(profil) ## List of 3 ## $ name: chr &quot;Till&quot; ## $ plz : num 60326 ## $ x :List of 3 ## ..$ : logi TRUE ## ..$ : logi TRUE ## ..$ : logi FALSE 4.5 Data Frames Data frames sind tabellarische Daten. Die Werte in jeder Spalte haben dabei denselben Typ. Viele Beispieldatensätze sind in Form von data frames in R eingebaut. head(x) gibt nur die ersten sechs Zeilen aus: head(mtcars) ## mpg cyl disp hp drat wt qsec ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 ## vs am gear carb ## Mazda RX4 0 1 4 4 ## Mazda RX4 Wag 0 1 4 4 ## Datsun 710 1 1 4 1 ## Hornet 4 Drive 1 0 3 1 ## Hornet Sportabout 0 0 3 2 ## Valiant 1 0 3 1 4.6 Tibbles Tibbles können alles, was data frames können, und haben darüber hinaus noch Funktionen, die wir später kennenlernen werden. Sie sind teil der Paketsammlung tidyverse, die einmalig installiert werden muss und dann geladen werden kann: library(tidyverse) Ein Beispieldatensatz ist diamonds: diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 ## 3 0.23 Good E VS1 56.9 65 327 4.05 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 ## 5 0.31 Good J SI2 63.3 58 335 4.34 ## 6 0.24 Very Go… J VVS2 62.8 57 336 3.94 ## 7 0.24 Very Go… I VVS1 62.3 57 336 3.95 ## 8 0.26 Very Go… H SI1 61.9 55 337 4.07 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 ## 10 0.23 Very Go… H VS1 59.4 61 338 4 ## # … with 53,930 more rows, and 2 more variables: ## # y &lt;dbl&gt;, z &lt;dbl&gt; Einzelne Spalten lassen sich mit $ ansprechen und verhalten sich dann wie Vektoren: str(diamonds$carat) ## num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... mean(diamonds$depth) ## [1] 61.7494 4.7 Aufgaben 4.7.1 Vektoren Generieren Sie die folgenden Vektoren (und seien Sie dabei möglichst faul). ## [1] TRUE FALSE FALSE ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE ## [9] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE ## [17] TRUE FALSE TRUE FALSE ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## [18] 18 19 20 ## [1] &quot;Z&quot; &quot;Y&quot; &quot;X&quot; &quot;W&quot; &quot;V&quot; &quot;U&quot; &quot;T&quot; &quot;S&quot; &quot;R&quot; &quot;Q&quot; &quot;P&quot; &quot;O&quot; ## [13] &quot;N&quot; &quot;M&quot; &quot;L&quot; &quot;K&quot; &quot;J&quot; &quot;I&quot; &quot;H&quot; &quot;G&quot; &quot;F&quot; &quot;E&quot; &quot;D&quot; &quot;C&quot; ## [25] &quot;B&quot; &quot;A&quot; ## [1] &quot;aA&quot; &quot;bB&quot; &quot;cC&quot; &quot;dD&quot; &quot;eE&quot; &quot;fF&quot; &quot;gG&quot; &quot;hH&quot; &quot;iI&quot; &quot;jJ&quot; ## [11] &quot;kK&quot; &quot;lL&quot; &quot;mM&quot; &quot;nN&quot; &quot;oO&quot; &quot;pP&quot; &quot;qQ&quot; &quot;rR&quot; &quot;sS&quot; &quot;tT&quot; ## [21] &quot;uU&quot; &quot;vV&quot; &quot;wW&quot; &quot;xX&quot; &quot;yY&quot; &quot;zZ&quot; Wandeln Sie die Typen der ersten drei obigen Vektoren um: ## [1] 1 0 0 ## [1] 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 ## [1] &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot; &quot;10&quot; &quot;12&quot; &quot;14&quot; &quot;16&quot; &quot;18&quot; &quot;20&quot; ## [11] &quot;22&quot; &quot;24&quot; &quot;26&quot; &quot;28&quot; &quot;30&quot; &quot;32&quot; &quot;34&quot; 4.7.2 Tibbles Schauen Sie sich den Beispieldatensatz faithful an. Wandeln Sie den Datensatz faithful in einen tibble um. Wenden Sie str() auf den Datensatz an. und Interpretieren Sie das Ergebnis. Erstellen Sie einen eigenen tibble mit Vornamen, Nachnamen und Alter von (ausgedachten?) Menschen. Lassen Sie sich nur die zweite Zeile des tibbles diamonds anzeigen Lassen Sie sich nur jede zweite Zeile des tibbles diamonds anzeigen 4.7.3 Statistik Berechnen Sie die durchschnittliche Eruptionszeit im Datensatz faithful (als tibble). Berechnen Sie Varianz und Standardabweichung der Karatzahl im Beispieldatensatz diamonds Was sagen die einzelnen Kennzahlen des Befehls summary(x) aus? 4.7.4 Swirl Absolvieren Sie die folgenden Swirl-Lektionen (Anleitung zu Swirl s. letzte Lektion): 3: Sequences of Numbers 4: Vectors 5: Missing Values 6: Subsetting Vectors 4.7.5 Recherche Nach welcher Methode berechnet R den Quartilsabstand einer Verteilung (im Unterschied zur Vorlesung)? Finden Sie fünf Befehle, die mit tibbles funktionieren, aber nicht mit data frames. Welche Pakete sind Teil des tidyverse? Wofür sind sie gedacht? Lesen Sie die Hilfe zu tibble::tibble. Recherchieren Sie eigenständig unklare Begriffe. 4.7.6 Kniffliges Kehren Sie auf möglichst elegante und allgemeingültige Weise die Reihenfolge eines Vektors um, ohne die Funktion rev() zu benutzen. "],["visualisierungen.html", "Sitzung 5 Visualisierungen 5.1 Lernziele dieser Sitzung 5.2 Voraussetzungen 5.3 Überblick 5.4 Visualisierung mit dem Standardpaket 5.5 Visualisierung mit ggplot() 5.6 Aufgaben", " Sitzung 5 Visualisierungen 5.1 Lernziele dieser Sitzung Sie können… einfache Befehle zur Visualisierung in Base R anwenden. die Grammatik von ggplot2 für Visualisierungen in Grundzügen wiedergeben und anwenden. eigene Ideen für Visualisierungen entwickeln und umsetzen. 5.2 Voraussetzungen Für diese Lektion benötigen wir das Paket tidyverse: library(tidyverse) Und einen Datensatz, der in Form eines tibble vorliegt. Der Beispieldatensatz diamonds wird mitgeliefert: diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 ## 3 0.23 Good E VS1 56.9 65 327 4.05 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 ## 5 0.31 Good J SI2 63.3 58 335 4.34 ## 6 0.24 Very Go… J VVS2 62.8 57 336 3.94 ## 7 0.24 Very Go… I VVS1 62.3 57 336 3.95 ## 8 0.26 Very Go… H SI1 61.9 55 337 4.07 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 ## 10 0.23 Very Go… H VS1 59.4 61 338 4 ## # … with 53,930 more rows, and 2 more variables: ## # y &lt;dbl&gt;, z &lt;dbl&gt; Wenn wir mögen, können wir ihn mit der Funktion data() explizit in unser Environment laden: data(diamonds) 5.3 Überblick Einen ersten Überblick kriegen wir zum Einen durch den Befehl str(), der uns die Typen in den Spalten anzeigt: str(diamonds) ## tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame) ## $ carat : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ depth : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ table : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ... ## $ price : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ... ## $ x : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... Zum Anderen gibt die Hilfefunktion Auskunft über den Datensatz und die einzelnen Variablen (Metadaten): ?diamonds Einen Überblick über die wichtigsten statistischen Parameter erhalten wir mit: summary(diamonds) ## carat cut color ## Min. :0.2000 Fair : 1610 D: 6775 ## 1st Qu.:0.4000 Good : 4906 E: 9797 ## Median :0.7000 Very Good:12082 F: 9542 ## Mean :0.7979 Premium :13791 G:11292 ## 3rd Qu.:1.0400 Ideal :21551 H: 8304 ## Max. :5.0100 I: 5422 ## J: 2808 ## clarity depth table ## SI1 :13065 Min. :43.00 Min. :43.00 ## VS2 :12258 1st Qu.:61.00 1st Qu.:56.00 ## SI2 : 9194 Median :61.80 Median :57.00 ## VS1 : 8171 Mean :61.75 Mean :57.46 ## VVS2 : 5066 3rd Qu.:62.50 3rd Qu.:59.00 ## VVS1 : 3655 Max. :79.00 Max. :95.00 ## (Other): 2531 ## price x y ## Min. : 326 Min. : 0.000 Min. : 0.000 ## 1st Qu.: 950 1st Qu.: 4.710 1st Qu.: 4.720 ## Median : 2401 Median : 5.700 Median : 5.710 ## Mean : 3933 Mean : 5.731 Mean : 5.735 ## 3rd Qu.: 5324 3rd Qu.: 6.540 3rd Qu.: 6.540 ## Max. :18823 Max. :10.740 Max. :58.900 ## ## z ## Min. : 0.000 ## 1st Qu.: 2.910 ## Median : 3.530 ## Mean : 3.539 ## 3rd Qu.: 4.040 ## Max. :31.800 ## 5.4 Visualisierung mit dem Standardpaket Es gibt in R mehrere grundlegend verschiedene Möblichkeiten, Daten zu visualiseren. Für einen schnellen Überblick sind z.B. hist() und boxplot() hilfreich: hist(diamonds$price) boxplot(diamonds$x) 5.5 Visualisierung mit ggplot() Das Paket ggplot2 ist Teil vom tidyverse. Hiermit lassen sich sehr flexible Graphiken gestalten. Wir werden ausschließlich mit diesem System arbeiten. Die Syntax ist dabei auf den ersten Blick etwas komplexer. Am Anfang steht der Befehl ggplot(x) mit dem Datensatz als Parameter ggplot(data=diamonds) Mit einem Mapping-Parameter legen wir die Dimensionen fest: ggplot(data=diamonds, mapping=aes(x=price, y=carat)) Das gleiche ohne Parameternamen: ggplot(diamonds, aes(price, carat)) Nun kann mit dem +-Operator ein geometrischer Layer hinzugefügt werden: ggplot(diamonds, aes(x=carat, y=price)) + geom_point() Weitere geom-Layer lassen sich mit dem +-Operator hinzufügen: ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth() Die Layer-Funktionen können durch Parameter angepasst werden: ggplot(diamonds, aes(x=carat, y=price)) + geom_point(size=0.5) + geom_smooth(color=&quot;red&quot;) Dabei lassen sich in den einzelnen Layers mappings hinzufügen oder verändern: ggplot(diamonds, aes(x=carat, y=price)) + geom_point(aes(color=clarity), size=0.5) + geom_smooth(color=&quot;red&quot;) Schließlich lassen sich noch viele weitere optische Aspekte anpassen, z.B. Achsen, Farben, etc.: ggplot(diamonds, aes(x=carat, y=price)) + geom_point(aes(color=clarity), size=0.5) + geom_smooth(color=&quot;red&quot;) + scale_x_continuous(&quot;Karatzahl&quot;, breaks=seq(0,5,0.5)) + scale_y_continuous(&quot;Preis&quot;) + scale_color_brewer(&quot;Klarheit&quot;) + theme_dark() 5.6 Aufgaben Versuchen Sie, folgende Visualisierungen des Datensatzes diamonds auszugeben: ggplot(diamonds, aes(x = cut)) + geom_bar(aes(fill = color)) ggplot(diamonds, aes(x = depth, y = price)) + geom_point(alpha = 0.1, aes(color = cut)) + guides(colour = guide_legend(override.aes = list(alpha = 1))) ggplot(diamonds, aes(x = color, y = price)) + geom_boxplot(aes(color = color), outlier.colour = NA) + facet_wrap(~cut) + theme(legend.position = &quot;none&quot;) + scale_x_discrete(&quot;Farbe&quot;) + scale_y_continuous(&quot;Preis&quot;) 5.6.1 R for Data Science Schauen Sie sich die Publikation R for Data Science an. Was ist das für ein Buch? Wer ist das Zielpublikum? Lesen Sie das Kapitel 3: Data Visualization und vollziehen Sie die Visualisierungen nach. Bearbeiten Sie die Aufgaben. Bearbeiten Sie die RStudio Primers zu Datenvisualisierung. "],["text-shelton-et-al-2014.html", "Sitzung 6 Text: Shelton et al. 2014 6.1 Lesetext 6.2 Fragen an den Text", " Sitzung 6 Text: Shelton et al. 2014 6.1 Lesetext Shelton, Taylor, Ate Poorthuis, Mark Graham und Matthew Zook. 2014. Mapping the Data Shadows of Hurricane Sandy. Uncovering the Sociospatial Dimensions of Big Data. Geoforum 52. 167–79. 6.2 Fragen an den Text Um welche Art von Text handelt es sich? Wer sind die Autoren, und an wen wenden sie sich? Was war Hurricane Sandy, von dem der Text erzählt? Warum wird ausgerechnet dieser Hurricane herangezogen? Welche Methoden wenden die Autoren an, und zu welchen Ergebnissen kommen sie? Im Abstract versprechen die Autoren: We also seek to fill a conceptual lacuna… Was heißt das, und wie geht der Text das an? In welchen Punkten finden Sie den Text überzeugend? Welche Kritik haben Sie am Text? "],["geodaten.html", "Sitzung 7 Geodaten 7.1 Lernziele dieser Sitzung 7.2 Voraussetzungen 7.3 Exkurs: Pipes 7.4 Daten importieren 7.5 Überblick verschaffen 7.6 Visualisieren 7.7 Aufgaben", " Sitzung 7 Geodaten 7.1 Lernziele dieser Sitzung Sie können… Pipes benutzen einfache dplyr-Befehle ausführen Koordinaten visualisieren 7.2 Voraussetzungen Wir laden erstmal tidyverse: library(tidyverse) 7.3 Exkurs: Pipes Teil vom tidyverse ist auch das Paket magrittr, das einen besonderen Operator enthält: %&gt;% Der Operator %&gt;% heißt Pipe und setzt das Ergebnis der vorherigen Funktion als ersten Parameter in die nächste Funktion ein. Zur Veranschaulichung: anzahl_buchstaben &lt;- length(letters) sqrt(anzahl_buchstaben) …ist das gleiche wie… sqrt(length(letters)) …ist das gleiche wie… length(letters) %&gt;% sqrt() …ist das gleiche wie… letters %&gt;% length %&gt;% sqrt() So können beliebig viele Funktionen aneinandergereiht werden. Und mit -&gt; kann eine Variable „in die andere Richtung“ zugewiesen werden letters %&gt;% length() %&gt;% sqrt() %&gt;% round() %&gt;% as.character() -&gt; my_var Gerade bei komplizierteren Zusammenhängen wird der Code so oft lesbarer, weil die Logik von links nach rechts, bzw. von oben nach unten gelesen werden kann. 7.4 Daten importieren Beim Open-Data-Portal der Stadt Frankfurt steht ein Baumkataster zur Verfügung. Die Datei im CSV-Format (comma separated values) kann entweder heruntergeladen und durch klicken importiert werden, oder direkt über den Befehl: baumkataster &lt;- read_csv2(&quot;http://offenedaten.frankfurt.de/dataset/73c5a6b3-c033-4dad-bb7d-8783427dd233/resource/7a73520b-961a-4aad-a582-449e676c247c/download/gprojekteopen-datadatenamt-67datenbaumauswahl_veroffentlichung_4baumauswahl_veroffentlichung_4.csv&quot;) 7.5 Überblick verschaffen Mit summary() lässt sich eine Zusammenfassung der Werte generieren: summary(baumkataster) ## Gattung/Art/Deutscher Name Baumnummer ## Length:118403 Min. : 1.0 ## Class :character 1st Qu.: 24.0 ## Mode :character Median : 82.0 ## Mean : 232.7 ## 3rd Qu.: 270.0 ## Max. :20158.0 ## NA&#39;s :1853 ## Objekt Pflanzjahr Kronendurchmesser ## Length:118403 Min. :1645 Min. : 2.000 ## Class :character 1st Qu.:1970 1st Qu.: 4.000 ## Mode :character Median :1982 Median : 6.000 ## Mean :1979 Mean : 6.688 ## 3rd Qu.:1995 3rd Qu.: 9.000 ## Max. :2017 Max. :63.000 ## ## HOCHWERT RECHTSWERT ## Min. :5545117 Min. :463163 ## 1st Qu.:5550428 1st Qu.:472715 ## Median :5552601 Median :475219 ## Mean :5552953 Mean :475244 ## 3rd Qu.:5555165 3rd Qu.:478201 ## Max. :5563639 Max. :485361 ## Genauere Infos über diese Merkmale gibt es auf dem Datenportal. 7.6 Visualisieren Wie in der letzten Lektion besprochen, lässt sich der Datensatz mit ggplot() visualisieren, z.B.: ggplot(baumkataster, aes(x=Kronendurchmesser)) + geom_histogram() Eine neue Messreihe lässt sich z.B. so errechnen: alter &lt;- 2020 - baumkataster$Pflanzjahr head(alter) ## [1] 100 100 100 100 100 100 Der Befehl mutate() funktioniert sehr ähnlich, gibt aber den veränderten Datensatz zurück: mutate(baumkataster, alter = 2020 - Pflanzjahr) ## # A tibble: 118,403 x 8 ## `Gattung/Art/De… Baumnummer Objekt Pflanzjahr ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Platanus x hisp… 1 Acker… 1920 ## 2 Platanus x hisp… 2 Acker… 1920 ## 3 Platanus x hisp… 3 Acker… 1920 ## 4 Platanus x hisp… 4 Acker… 1920 ## 5 Platanus x hisp… 5 Acker… 1920 ## 6 Platanus x hisp… 6 Acker… 1920 ## 7 Platanus x hisp… 7 Acker… 1920 ## 8 Platanus x hisp… 8 Acker… 1920 ## 9 Platanus x hisp… 9 Acker… 1920 ## 10 Platanus x hisp… 10 Acker… 1920 ## # … with 118,393 more rows, and 4 more variables: ## # Kronendurchmesser &lt;dbl&gt;, HOCHWERT &lt;dbl&gt;, ## # RECHTSWERT &lt;dbl&gt;, alter &lt;dbl&gt; Derselbe Befehl mit dem Pipe-Operator: baumkataster %&gt;% mutate(alter = 2020 - Pflanzjahr) ## # A tibble: 118,403 x 8 ## `Gattung/Art/De… Baumnummer Objekt Pflanzjahr ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Platanus x hisp… 1 Acker… 1920 ## 2 Platanus x hisp… 2 Acker… 1920 ## 3 Platanus x hisp… 3 Acker… 1920 ## 4 Platanus x hisp… 4 Acker… 1920 ## 5 Platanus x hisp… 5 Acker… 1920 ## 6 Platanus x hisp… 6 Acker… 1920 ## 7 Platanus x hisp… 7 Acker… 1920 ## 8 Platanus x hisp… 8 Acker… 1920 ## 9 Platanus x hisp… 9 Acker… 1920 ## 10 Platanus x hisp… 10 Acker… 1920 ## # … with 118,393 more rows, and 4 more variables: ## # Kronendurchmesser &lt;dbl&gt;, HOCHWERT &lt;dbl&gt;, ## # RECHTSWERT &lt;dbl&gt;, alter &lt;dbl&gt; So lassen sich auch hier verschiedene Befehle verknüpfen. filter() beschränkt den Datensatz auf Merkmalsträger, die den Kriterien entsprechen: baumkataster %&gt;% mutate(alter = 2020 - Pflanzjahr) %&gt;% filter(alter &gt; 30) -&gt; alte_baeume summary(alte_baeume) ## Gattung/Art/Deutscher Name Baumnummer ## Length:73859 Min. : 1.0 ## Class :character 1st Qu.: 29.0 ## Mode :character Median : 97.0 ## Mean : 263.2 ## 3rd Qu.: 314.0 ## Max. :10489.0 ## NA&#39;s :684 ## Objekt Pflanzjahr Kronendurchmesser ## Length:73859 Min. :1645 Min. : 2.000 ## Class :character 1st Qu.:1960 1st Qu.: 6.000 ## Mode :character Median :1974 Median : 8.000 ## Mean :1966 Mean : 8.503 ## 3rd Qu.:1980 3rd Qu.:10.000 ## Max. :1989 Max. :35.000 ## ## HOCHWERT RECHTSWERT alter ## Min. :5545117 Min. :463163 Min. : 31.00 ## 1st Qu.:5550415 1st Qu.:472667 1st Qu.: 40.00 ## Median :5552480 Median :475708 Median : 46.00 ## Mean :5552593 Mean :475402 Mean : 53.54 ## 3rd Qu.:5554589 3rd Qu.:478539 3rd Qu.: 60.00 ## Max. :5563639 Max. :485360 Max. :375.00 ## Schließlich ergibt das Streudiagramm von Koordinaten so eine art Karte: ggplot(alte_baeume) + geom_point(size = 0.1, aes(x = RECHTSWERT, y = HOCHWERT)) Diesen Ansatz werden wir in der nächsten Lektion vertiefen. 7.7 Aufgaben Besuchen Sie https://pleiades.stoa.org/ - worum geht es hier? Finden Sie den kompletten aktuellen Datensatz für „locations“ als CSV-Datei. Importieren Sie ihn in R und weisen Sie dem Datensatz den Namen pleiades zu. pleiades &lt;- read_csv(&quot;http://atlantides.org/downloads/pleiades/dumps/pleiades-locations-latest.csv.gz&quot;) Finden Sie geeignete Werte für (einzelne) Längen- und Breitengrade im Datensatz. pleiades$reprLong %&gt;% # Längengrad summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -16.910 8.047 17.500 19.890 30.722 111.078 ## NA&#39;s ## 7316 pleiades$reprLat %&gt;% # Breitengrad summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -20.00 36.25 39.11 39.53 43.73 62.50 ## NA&#39;s ## 7316 Plotten Sie die Koordinaten auf x- und y-Achse mit ggplot(). Was erkennen Sie? ggplot(pleiades) + geom_point(aes(x = reprLong, y = reprLat)) Halbieren Sie die Größe und setzen Sie den Alpha-Wert der Punkte auf 0,2. ggplot(pleiades) + geom_point(aes(x = reprLong, y = reprLat), size = 0.5, alpha = 0.2) Bringen Sie die Grafik in die Mercator-Projektion. ggplot(pleiades) + geom_point(aes(x = reprLong, y = reprLat), size = 0.5, alpha = 0.2) + coord_map(&quot;mercator&quot;) Schauen Sie sich diesen Befehl an: map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group)) + coord_quickmap(xlim = c(-8, 40), ylim = c(26, 48)) Versuchen Sie, jede einzelne Zeile nachzuvollziehen, indem Sie die entsprechenden Funktionen recherchieren. Führen Sie den Befehl aus. Ändern Sie die Farbe der Flächen in hellgrau. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_quickmap(xlim = c(-8, 40), ylim = c(26, 48)) Wählen Sie einen Kartenausschnitt, auf dem Portugal, Ägypten, Irak und Frankreich komplett zu sehen sind. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_quickmap(xlim = c(-8, 48), ylim = c(22, 50)) Plotten Sie auf diesem Hintergrund den Datensatz pleiades. Passen Sie dabei die Parameter so an, dass es Ihnen optisch zusagt. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_quickmap(xlim = c(-8, 48), ylim = c(22, 50)) + geom_point(data = pleiades, mapping = aes(x = reprLong, y = reprLat), color = &quot;blue&quot;, size = 0.3, alpha = 0.5) Wählen Sie für die Karte die Bonnesche Projektion mit Standardparallele bei 40°N. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_map(&quot;bonne&quot;, 40, xlim = c(-8, 48), ylim = c(22, 50)) + geom_point(data = pleiades, mapping = aes(x = reprLong, y = reprLat), color = &quot;blue&quot;, size = 0.3, alpha = 0.5) Entfernen Sie alle Achsenbeschriftungen. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_map(&quot;bonne&quot;, 40, xlim = c(-8, 48), ylim = c(22, 50)) + geom_point(data = pleiades, mapping = aes(x = reprLong, y = reprLat), color = &quot;blue&quot;, size = 0.3, alpha = 0.5) + theme(axis.title = element_blank(), axis.ticks = element_blank(), axis.text = element_blank()) (Achtung: extrem knifflig!) Bilden Sie diese Grafik nach, die die Orte geordnet nach ältestem Fund darstellt: pleiades %&gt;% select(long = reprLong, lat = reprLat, timePeriods) %&gt;% mutate(oldest = str_extract(timePeriods, &quot;[ACHRL]&quot;)) %&gt;% mutate(oldest = factor(oldest, levels = c(&quot;A&quot;, &quot;C&quot;, &quot;H&quot;, &quot;R&quot;, &quot;L&quot;))) -&gt; pleiades_periods map_data(&quot;world&quot;) %&gt;% filter(region != &quot;Antarctica&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(long, lat, group = group), fill = &quot;darkgreen&quot;) + coord_map(&quot;albers&quot;, parameters = c(16, 37), xlim = c(-8, 40), ylim = c(26, 48)) + geom_point(data = pleiades_periods, mapping = aes(long, lat, color = oldest), size = 0.2, alpha = 0.3) + scale_color_brewer(&quot;Früheste Epoche&quot;, breaks = c(&quot;A&quot;, &quot;C&quot;, &quot;H&quot;, &quot;R&quot;, &quot;L&quot;), labels = c(&quot;1000-550 v.d.Z.&quot;, &quot;550-330 v.d.Z.&quot;, &quot;330 v.d.Z. - 30 n.d.Z.&quot;, &quot;30-300 n.d.Z.&quot;, &quot;300-640 n.d.Z.&quot;), palette = &quot;YlOrBr&quot;) + theme(axis.title = element_blank(), axis.ticks = element_blank(), axis.text = element_blank(), panel.background = element_rect(fill = &quot;darkblue&quot;), panel.grid = element_line(color = &quot;blue&quot;)) + guides(colour = guide_legend(override.aes = list(alpha = 1, size = 8, shape = 15))) "],["choroplethen.html", "Sitzung 8 Choroplethen 8.1 Lernziele 8.2 Vorbereitung 8.3 Ziel 8.4 Grundkarte 8.5 OSM-Daten 8.6 Koordinatenreferenzsysteme 8.7 Verschneiden 8.8 Aufgaben", " Sitzung 8 Choroplethen 8.1 Lernziele Sie können… Geodaten als Simple Features importieren, CRS bestimmen und umwandeln, einfache Verschneidungen von Simple Features durchführen und Simple Features kartographisch darstellen. 8.2 Vorbereitung Für diese Lektion werden zwei Pakete geladen: library(tidyverse) library(sf) 8.3 Ziel Ziel ist, eine Choroplethenkarte von Frankfurt zu erstellen, die die Versorgung mit Kiosken darstellt. 8.4 Grundkarte Eine Shapefile der Frankfurter Stadtteile findet sich hier: http://www.offenedaten.frankfurt.de/dataset/frankfurter-stadtteilgrenzen-fur-gis-systeme Wir laden die Zip-Datei herunter und speichern den enthaltenen Ordner stadtteile in unserem Arbeitsverzeichnis. Es ist eine gute Angewohnheit, einen Unterordner für Ressourcen anzulegen. Dann importieren wir den Geodatensatz als Simple Features (Paket sf): stadtteile &lt;- st_read(&quot;resources/stadtteile/Stadtteile_Frankfurt_am_Main.shp&quot;) ## Reading layer `Stadtteile_Frankfurt_am_Main&#39; from data source `/Users/till/teaching/2020x21_Data_Science/public/resources/stadtteile/Stadtteile_Frankfurt_am_Main.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 46 features and 2 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 462292.7 ymin: 5540412 xmax: 485744.8 ymax: 5563925 ## projected CRS: ETRS89 / UTM zone 32N Simple Features sind Datensätze, die eine Spalte geometry enthalten, in der Geodaten in einem standardisierten Format hinterlegt sind. str(stadtteile) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 46 obs. of 3 variables: ## $ STTLNR : num 1 2 3 4 5 6 7 8 9 10 ... ## $ STTLNAME: Factor w/ 46 levels &quot;Altstadt&quot;,&quot;Bahnhofsviertel&quot;,..: 1 22 2 45 44 30 29 32 7 17 ... ## $ geometry:sfc_POLYGON of length 46; first list element: List of 1 ## ..$ : num [1:46, 1:2] 476934 476890 476852 476813 476799 ... ## ..- attr(*, &quot;class&quot;)= chr &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA ## ..- attr(*, &quot;names&quot;)= chr &quot;STTLNR&quot; &quot;STTLNAME&quot; Eine Vorschau: ggplot(stadtteile) + geom_sf() + geom_sf_label(aes(label = STTLNAME), size = 2) 8.5 OSM-Daten Im OSM Wiki suchen wir den richtigen tag heraus. In diesem Fall shop=kiosk Dann bauen wir auf Overpass Turbo die Abfrage und laden den Datensatz herunter. Schließlich importieren wir: kioske &lt;- st_read(&quot;resources/kioske.geojson&quot;) ## Reading layer `kioske&#39; from data source `/Users/till/teaching/2020x21_Data_Science/public/resources/kioske.geojson&#39; using driver `GeoJSON&#39; ## Simple feature collection with 325 features and 74 fields ## geometry type: GEOMETRY ## dimension: XY ## bbox: xmin: 8.505468 ymin: 50.04801 xmax: 8.789538 ymax: 50.20185 ## geographic CRS: WGS 84 Eine Vorschau: ggplot() + geom_sf(data = stadtteile) + geom_sf(data = kioske) 8.6 Koordinatenreferenzsysteme Der OSM-Datensatz ist mit WGS84 (EPSG 4326) referenziert: st_crs(kioske) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] Die Stadtteilen hingegen sind sind in ETSR89 (EPSG 25832): st_crs(stadtteile) ## Coordinate Reference System: ## User input: ETRS89 / UTM zone 32N ## wkt: ## PROJCRS[&quot;ETRS89 / UTM zone 32N&quot;, ## BASEGEOGCRS[&quot;ETRS89&quot;, ## DATUM[&quot;European Terrestrial Reference System 1989&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4258]], ## CONVERSION[&quot;UTM zone 32N&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,9, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,500000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;Engineering survey, topographic mapping.&quot;], ## AREA[&quot;Europe between 6°E and 12°E: Austria; Belgium; Denmark - onshore and offshore; Germany - onshore and offshore; Norway including - onshore and offshore; Spain - offshore.&quot;], ## BBOX[38.76,6,83.92,12]], ## ID[&quot;EPSG&quot;,25832]] Der Datensatz lässt sich allerdings transformieren: stadtteile %&gt;% st_transform(4326) %&gt;% st_crs() ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] Jetzt haben beide Datensätze den selben EPSG-Code. Das ist die Voraussetzung für den nächsten Schritt. 8.7 Verschneiden Mit st_covers() und lengths() lassen sich die Anzahl der Kioske in jedem Stadtteil zählen und einer neuen Spalte im Originaldatensatz zuordnen: stadtteile %&gt;% st_transform(4326) %&gt;% st_covers(kioske) %&gt;% lengths() -&gt; stadtteile$anzahl_kioske Auf einer Karte veranschaulicht: ggplot(stadtteile) + geom_sf(aes(fill = anzahl_kioske)) Allerdings wäre es schöner, die Kioskdichte (nach Fläche) darzustellen. Dazu berechnen wir zunächst die Flächen der Stadtteile: st_area(stadtteile) %&gt;% as.numeric() / 1000 / 1000 -&gt; stadtteile$qkm Oder mit Pipes: stadtteile %&gt;% mutate(qkm = st_area(.) %&gt;% as.numeric() / 1000 / 1000) ## Simple feature collection with 46 features and 4 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 462292.7 ymin: 5540412 xmax: 485744.8 ymax: 5563925 ## projected CRS: ETRS89 / UTM zone 32N ## First 10 features: ## STTLNR STTLNAME ## 1 1 Altstadt ## 2 2 Innenstadt ## 3 3 Bahnhofsviertel ## 4 4 Westend-Süd ## 5 5 Westend-Nord ## 6 6 Nordend-West ## 7 7 Nordend-Ost ## 8 8 Ostend ## 9 9 Bornheim ## 10 10 Gutleutviertel ## geometry anzahl_kioske ## 1 POLYGON ((476934.3 5550541,... 5 ## 2 POLYGON ((477611.9 5552034,... 5 ## 3 POLYGON ((475831 5550785, 4... 7 ## 4 POLYGON ((475745.4 5552373,... 6 ## 5 POLYGON ((476497.9 5553910,... 3 ## 6 POLYGON ((478362.5 5553898,... 10 ## 7 POLYGON ((478397.9 5551924,... 17 ## 8 POLYGON ((481955.2 5552141,... 15 ## 9 POLYGON ((478959.8 5552336,... 14 ## 10 POLYGON ((472942 5548802, 4... 11 ## qkm ## 1 0.5065673 ## 2 1.4902009 ## 3 0.5425421 ## 4 2.4948957 ## 5 1.6307925 ## 6 3.0977694 ## 7 1.5305338 ## 8 5.5573382 ## 9 2.7840413 ## 10 2.1982354 Und dann die Kioskdichte: stadtteile %&gt;% mutate(qkm = st_area(.) %&gt;% as.numeric() / 1000 / 1000, kioskdichte = anzahl_kioske / qkm) ## Simple feature collection with 46 features and 5 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 462292.7 ymin: 5540412 xmax: 485744.8 ymax: 5563925 ## projected CRS: ETRS89 / UTM zone 32N ## First 10 features: ## STTLNR STTLNAME ## 1 1 Altstadt ## 2 2 Innenstadt ## 3 3 Bahnhofsviertel ## 4 4 Westend-Süd ## 5 5 Westend-Nord ## 6 6 Nordend-West ## 7 7 Nordend-Ost ## 8 8 Ostend ## 9 9 Bornheim ## 10 10 Gutleutviertel ## geometry anzahl_kioske ## 1 POLYGON ((476934.3 5550541,... 5 ## 2 POLYGON ((477611.9 5552034,... 5 ## 3 POLYGON ((475831 5550785, 4... 7 ## 4 POLYGON ((475745.4 5552373,... 6 ## 5 POLYGON ((476497.9 5553910,... 3 ## 6 POLYGON ((478362.5 5553898,... 10 ## 7 POLYGON ((478397.9 5551924,... 17 ## 8 POLYGON ((481955.2 5552141,... 15 ## 9 POLYGON ((478959.8 5552336,... 14 ## 10 POLYGON ((472942 5548802, 4... 11 ## qkm kioskdichte ## 1 0.5065673 9.870357 ## 2 1.4902009 3.355252 ## 3 0.5425421 12.902225 ## 4 2.4948957 2.404910 ## 5 1.6307925 1.839596 ## 6 3.0977694 3.228129 ## 7 1.5305338 11.107236 ## 8 5.5573382 2.699134 ## 9 2.7840413 5.028661 ## 10 2.1982354 5.004014 Schließlich die Karte: stadtteile %&gt;% mutate(qkm = st_area(.) %&gt;% as.numeric() / 1000 / 1000, kioskdichte = anzahl_kioske / qkm) %&gt;% ggplot() + geom_sf(aes(fill = kioskdichte), color=NA) + scale_fill_continuous(&quot;Kioske pro km²&quot;) + theme_void() 8.8 Aufgaben Erstellen Sie eine Choroplethenkarte der Frankfurter Stadtteile, in der Sie die Anzahl bzw. die Dichte von Apotheken darstellen. (Schritte analog zu oben.) # Aus dem OSM-Wiki erfahren wir, dass die Abfrage lautet: amenity=pharmacy # Auf Overpass Turbo lässt sich das Resultat als geoJSON exportieren. stadtteile %&gt;% st_transform(4326) %&gt;% st_covers(st_read(&quot;resources/apotheken.geojson&quot;)) %&gt;% lengths() -&gt; stadtteile$anzahl_apotheken ## Reading layer `apotheken&#39; from data source `/Users/till/teaching/2020x21_Data_Science/public/resources/apotheken.geojson&#39; using driver `GeoJSON&#39; ## Simple feature collection with 257 features and 61 fields ## geometry type: GEOMETRY ## dimension: XY ## bbox: xmin: 8.466004 ymin: 50.04214 xmax: 8.834962 ymax: 50.21252 ## geographic CRS: WGS 84 stadtteile %&gt;% mutate(qkm = st_area(.) %&gt;% as.numeric() / 1000 / 1000, apothekendichte = anzahl_apotheken/ qkm) %&gt;% ggplot() + geom_sf(aes(fill = apothekendichte), color = NA) + scale_fill_continuous(&quot;Apotheken pro km²&quot;) Welche Stadtteile haben mehr Kioske? Welche mehr Apotheken? Wie ausgeprägt ist das Verhältnis? Erstellen Sie eine Karte, die das zum Ausdruck bringt. stadtteile %&gt;% mutate(ratio = (anzahl_apotheken - anzahl_kioske) / (anzahl_apotheken + anzahl_kioske)) %&gt;% ggplot() + geom_sf(aes(fill = ratio), color=NA) + scale_fill_continuous(NULL, type = &quot;viridis&quot;, breaks = seq(1, -1, -0.5), labels = c(&quot;nur Apotheken&quot;, &quot;mehr Apotheken&quot;, &quot;gleiche Anzahl&quot;, &quot;mehr Kioske&quot;, &quot;nur Kioske&quot;)) + theme_void() (Achtung, knifflig!) Siemens veröffentlicht einen Blitzatlas. Laden Sie den Datensatz herunter und bauen Sie die folgende Ansicht nach: &quot;resources/Uebersicht-Blitzeinschlaege-2019.xlsx&quot; %&gt;% readxl::read_excel() %&gt;% rowwise() %&gt;% mutate(Dichte2016 = `Dichte 2016`, DichteGesamt = mean(c(Dichte2015, Dichte2016, Dichte2017, Dichte2018, Dichte2019)), kreis = `Stadt- oder Landkreis` %&gt;% str_remove(&quot;(LK) |(SK) &quot;)) %&gt;% select(-`Dichte 2016`) %&gt;% pivot_longer(starts_with(&quot;Dichte&quot;), names_prefix = &quot;Dichte&quot;, names_to = &quot;Jahr&quot;, values_to = &quot;Blitzdichte&quot;) %&gt;% select(kreis, Jahr, Blitzdichte) -&gt; blitze # Landkreise gibt es z.B. vom GDZ: https://gdz.bkg.bund.de/ # Datensatz: Verwaltungsgebiete 1:250 000 mit Einwohnerzahlen (Ebenen) &quot;resources/vg250-ew_3112.gk3.shape.ebenen/vg250-ew_ebenen_3112/VG250_KRS.shp&quot; %&gt;% read_sf() %&gt;% filter(str_detect(RS, &quot;^06&quot;)) %&gt;% left_join(blitze, by = c(&quot;GEN&quot; = &quot;kreis&quot;)) %&gt;% ggplot() + geom_sf(aes(fill = Blitzdichte), color=NA) + facet_wrap(~Jahr) + scale_fill_continuous(type=&quot;viridis&quot;) + theme(axis.ticks = element_blank(), axis.text = element_blank(), panel.grid = element_blank()) "],["text-chandra-2014.html", "Sitzung 9 Text: Chandra 2014 9.1 Lesetext 9.2 Fragen an den Text 9.3 Themenfindung", " Sitzung 9 Text: Chandra 2014 9.1 Lesetext Chandra, Vikram. 2014. Geek Sublime: The Beauty of Code, the Code of Beauty. Graywolf Press, Minneapolis. Daraus: Kapitel 1: Hello, World! (S. 1–8) Kapitel 3: The Language of Logic (S. 19–40) 9.2 Fragen an den Text Um welche Art von Text handelt es sich? Wer ist der Autor, und an wen wendet er sich? Was ist literate programming, und was könnte das in R konkret bedeuten? Auf S. 37 ist die Rede von our journey down the stack of languages. Was ist damit gemeint? Was findet der Autor an Code und Computern so faszinierend? Wo können Sie das nachvollziehen, und wo nicht? 9.3 Themenfindung Bereiten Sie ein Thema vor, zu dem Sie sich vorstellen könnten im Sommer zu arbeiten. Achten Sie darauf, dass das Thema nicht zu allgemein ist (Finanzmarkt) aber auch nicht zu speziell (Zusammenhang zwischen Quadratmeterzahl und Mietpreis für Ladenflächen in Ginnheim). Es wird in einem nächsten Schritt darum gehen, interessante Datenquellen zu finden (vielleicht haben Sie schon eine Idee?) und einer Fragestellung näher zu kommen. Sie werden die Themen kurz vorstellen um Überschneidungen zu identifizieren und ggf. Gruppen zu bilden (wenn gewünscht). "],["html-tabellen.html", "Sitzung 10 HTML-Tabellen 10.1 Lernziele dieser Sitzung 10.2 Vorbereitung 10.3 Datenbeschaffung 10.4 Datenformatierung 10.5 Datenaufbereitung 10.6 Datenvisualisierung 10.7 Aufgaben", " Sitzung 10 HTML-Tabellen 10.1 Lernziele dieser Sitzung Sie können… sich den Quellcode einer Webseite anzeigen lassen und interpretieren. HTML-Tabellen als Datensatz einlesen. Fortgeschrittene Methoden der Datenbereinigung nachvollziehen. 10.2 Vorbereitung Am Beispiel der Küstenlängen verschiedener Länder besprechen wir Techniken der Datenerhebung/-erfassung und -visualisierung. Unser Ziel ist es, die Daten zu den Küstenlängen in einer Grafik darzustellen. Für die folgenden Aufgaben benötigen wir die Pakete rvest und tidyverse. Zunächst müssen diese installiert und in unsere Umgebung geladen werden. library(tidyverse) library(rvest) 10.3 Datenbeschaffung Auf dem Internetauftritt der CIA gab es es eine Tabelle, welche die Küstenlänge (inklusive der Inseln) der einzelnen Länder enthält. Über die Archivierungsplattform WayBackMachine ist die Seite immer noch abrufbar: https://web.archive.org/web/20190802010710/https://www.cia.gov/library/publications/the-world-factbook/fields/282.html In einem ersten Schritt wird die URL der Tabelle der Variable url zugewiesen, sodass der Quellcode mit dem Befehl read_html() eingelesen werden kann. url &lt;- &quot;https://web.archive.org/web/20190802010710/https://www.cia.gov/library/publications/the-world-factbook/fields/282.html&quot; reply &lt;- read_html(url) Der Befehl html_table() ermöglicht das Auslesen aller Tabellen auf der Seite. Mithilfe des Befehls str() sehen wir, dass die Seite genau eine Tabelle enthält, welche die Informationen zu den Küstenlängen enthält. tables &lt;- html_table(reply, fill = TRUE) str(tables) ## List of 1 ## $ :&#39;data.frame&#39;: 266 obs. of 2 variables: ## ..$ Country : chr [1:266] &quot;Afghanistan&quot; &quot;Akrotiri&quot; &quot;Albania&quot; &quot;Algeria&quot; ... ## ..$ Coastline: chr [1:266] &quot;0 km\\n (landlocked)&quot; &quot;56.3 km&quot; &quot;362 km&quot; &quot;998 km&quot; ... Durch die Umformung zu einem tibble erhalten wir eine Tabelle mit den gewünschten Informationen: as_tibble(tables[[1]]) ## # A tibble: 266 x 2 ## Country Coastline ## &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan &quot;0 km\\n (landlocked)&quot; ## 2 Akrotiri &quot;56.3 km&quot; ## 3 Albania &quot;362 km&quot; ## 4 Algeria &quot;998 km&quot; ## 5 American Samoa &quot;116 km&quot; ## 6 Andorra &quot;0 km\\n (landlocked)&quot; ## 7 Angola &quot;1,600 km&quot; ## 8 Anguilla &quot;61 km&quot; ## 9 Antarctica &quot;17,968 km&quot; ## 10 Antigua and Barbuda &quot;153 km&quot; ## # … with 256 more rows Mit pipes können wir die obigen Befehle zusammenfassen und somit das Ganze auf einmal ausführen. &quot;https://web.archive.org/web/20190802010710/https://www.cia.gov/library/publications/the-world-factbook/fields/282.html&quot; %&gt;% read_html() %&gt;% html_table(fill = T) %&gt;% .[[1]] %&gt;% as_tibble() -&gt; coast 10.4 Datenformatierung Zur Datenformatierung nutzen wir Funktionen aus dem Paket stringr. Die Spalte mit der Küstenlänge soll keinen Text, keine Einheit direkt hinter den Zahlenwerten und keine Kommata zur Trennung der Zahlenwerte enthalten. Der Befehl str_extract() sucht nach vorgegebenen Mustern (engl. patterns) und wählt diese aus. Diese patterns werden auch reguläre Ausdrücke (regular expressions / regex) genannt und sind eigentlich ein Thema für sich. Das Pattern [0-9,.]+ km extrahiert die Kilometerangaben. km &lt;- str_extract(coast$Coastline, &quot;[0-9,.]+ km&quot;) Die ausgewählten Muster (in unserem Fall Kommata und Text) können durch den Befehl str_replace_all() gelöscht oder ersetzt werden. Wir ersetzen alle Zeichen außer Zahlen und Dezimalpunkt mit einem leeren String, so dass sie verschwinden. str_replace_all(km, &quot;[^0-9.]&quot;, &quot;&quot;) ## [1] &quot;0&quot; &quot;56.3&quot; &quot;362&quot; &quot;998&quot; &quot;116&quot; ## [6] &quot;0&quot; &quot;1600&quot; &quot;61&quot; &quot;17968&quot; &quot;153&quot; ## [11] &quot;45389&quot; &quot;4989&quot; &quot;0&quot; &quot;68.5&quot; &quot;74.1&quot; ## [16] &quot;111866&quot; &quot;25760&quot; &quot;0&quot; &quot;0&quot; &quot;3542&quot; ## [21] &quot;161&quot; &quot;580&quot; &quot;97&quot; &quot;0&quot; &quot;66.5&quot; ## [26] &quot;386&quot; &quot;121&quot; &quot;103&quot; &quot;0&quot; &quot;0&quot; ## [31] &quot;20&quot; &quot;0&quot; &quot;29.6&quot; &quot;7491&quot; &quot;698&quot; ## [36] &quot;80&quot; &quot;161&quot; &quot;354&quot; &quot;0&quot; &quot;1930&quot; ## [41] &quot;0&quot; &quot;965&quot; &quot;443&quot; &quot;402&quot; &quot;202080&quot; ## [46] &quot;160&quot; &quot;0&quot; &quot;0&quot; &quot;6435&quot; &quot;14500&quot; ## [51] &quot;138.9&quot; &quot;11.1&quot; &quot;26&quot; &quot;3208&quot; &quot;340&quot; ## [56] &quot;37&quot; &quot;169&quot; &quot;120&quot; &quot;3095&quot; &quot;1290&quot; ## [61] &quot;515&quot; &quot;5835&quot; &quot;3735&quot; &quot;364&quot; &quot;648&quot; ## [66] &quot;0&quot; &quot;7314&quot; &quot;27.5&quot; &quot;314&quot; &quot;148&quot; ## [71] &quot;1288&quot; &quot;2237&quot; &quot;2450&quot; &quot;307&quot; &quot;296&quot; ## [76] &quot;2234&quot; &quot;3794&quot; &quot;0&quot; &quot;0&quot; &quot;65992.9&quot; ## [81] &quot;1288&quot; &quot;1117&quot; &quot;1129&quot; &quot;1250&quot; &quot;4853&quot; ## [86] &quot;2525&quot; &quot;28&quot; &quot;885&quot; &quot;80&quot; &quot;40&quot; ## [91] &quot;310&quot; &quot;2389&quot; &quot;539&quot; &quot;12&quot; &quot;13676&quot; ## [96] &quot;44087&quot; &quot;121&quot; &quot;125.5&quot; &quot;400&quot; &quot;50&quot; ## [101] &quot;320&quot; &quot;350&quot; &quot;459&quot; &quot;1771&quot; &quot;101.9&quot; ## [106] &quot;0&quot; &quot;823&quot; &quot;733&quot; &quot;6.4&quot; &quot;0&quot; ## [111] &quot;4970&quot; &quot;7000&quot; &quot;66526&quot; &quot;54716&quot; &quot;2440&quot; ## [116] &quot;58&quot; &quot;1448&quot; &quot;160&quot; &quot;273&quot; &quot;7600&quot; ## [121] &quot;1022&quot; &quot;124.1&quot; &quot;29751&quot; &quot;8&quot; &quot;70&quot; ## [126] &quot;34&quot; &quot;26&quot; &quot;0&quot; &quot;536&quot; &quot;3&quot; ## [131] &quot;1143&quot; &quot;2495&quot; &quot;2413&quot; &quot;0&quot; &quot;499&quot; ## [136] &quot;0&quot; &quot;0&quot; &quot;498&quot; &quot;225&quot; &quot;0&quot; ## [141] &quot;579&quot; &quot;1770&quot; &quot;0&quot; &quot;90&quot; &quot;0&quot; ## [146] &quot;41&quot; &quot;4828&quot; &quot;0&quot; &quot;4675&quot; &quot;644&quot; ## [151] &quot;0&quot; &quot;196.8&quot; &quot;370.4&quot; &quot;754&quot; &quot;177&quot; ## [156] &quot;9330&quot; &quot;6112&quot; &quot;15&quot; &quot;0&quot; &quot;4.1&quot; ## [161] &quot;0&quot; &quot;293.5&quot; &quot;40&quot; &quot;1835&quot; &quot;2470&quot; ## [166] &quot;1572&quot; &quot;30&quot; &quot;8&quot; &quot;0&quot; &quot;451&quot; ## [171] &quot;2254&quot; &quot;15134&quot; &quot;910&quot; &quot;0&quot; &quot;853&quot; ## [176] &quot;64&quot; &quot;32&quot; &quot;0&quot; &quot;1482&quot; &quot;25148&quot; ## [181] &quot;2092&quot; &quot;135663&quot; &quot;1046&quot; &quot;1519&quot; &quot;14.5&quot; ## [186] &quot;2490&quot; &quot;5152&quot; &quot;518&quot; &quot;0&quot; &quot;2414&quot; ## [191] &quot;36289&quot; &quot;51&quot; &quot;440&quot; &quot;1793&quot; &quot;501&quot; ## [196] &quot;563&quot; &quot;225&quot; &quot;37653&quot; &quot;0&quot; &quot;60&quot; ## [201] &quot;135&quot; &quot;158&quot; &quot;58.9&quot; &quot;120&quot; &quot;84&quot; ## [206] &quot;403&quot; &quot;0&quot; &quot;209&quot; &quot;2640&quot; &quot;531&quot; ## [211] &quot;0&quot; &quot;491&quot; &quot;402&quot; &quot;193&quot; &quot;58.9&quot; ## [216] &quot;0&quot; &quot;46.6&quot; &quot;5313&quot; &quot;3025&quot; &quot;2798&quot; ## [221] NA &quot;0&quot; &quot;17968&quot; &quot;4964&quot; &quot;926&quot; ## [226] &quot;1340&quot; &quot;853&quot; &quot;386&quot; &quot;3587&quot; &quot;3218&quot; ## [231] &quot;0&quot; &quot;193&quot; &quot;1566.3&quot; &quot;0&quot; &quot;1424&quot; ## [236] &quot;3219&quot; &quot;706&quot; &quot;56&quot; &quot;101&quot; &quot;419&quot; ## [241] &quot;362&quot; &quot;1148&quot; &quot;7200&quot; &quot;0&quot; &quot;389&quot; ## [246] &quot;24&quot; &quot;0&quot; &quot;2782&quot; &quot;1318&quot; &quot;12429&quot; ## [251] &quot;19924&quot; &quot;4.8&quot; &quot;660&quot; &quot;0&quot; &quot;2528&quot; ## [256] &quot;2800&quot; &quot;3444&quot; &quot;188&quot; &quot;19.3&quot; &quot;129&quot; ## [261] &quot;0&quot; &quot;1110&quot; &quot;356000&quot; &quot;1906&quot; &quot;0&quot; ## [266] &quot;0&quot; Auch hier kann alles in einen Befehl gepackt werden: coast$Coastline %&gt;% str_extract(&quot;[0-9,.]+ km&quot;) %&gt;% str_replace_all(&quot;[^0-9.]&quot;, &quot;&quot;) %&gt;% as.numeric() -&gt; coast$coast_num 10.5 Datenaufbereitung Mit dem Befehl arrange() kann die Tabelle sortiert werden. Zunächst auftseigend, coast %&gt;% arrange(coast_num) ## # A tibble: 266 x 3 ## Country Coastline coast_num ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanist… &quot;0 km\\n (landlocked)&quot; 0 ## 2 Andorra &quot;0 km\\n (landlocked)&quot; 0 ## 3 Armenia &quot;0 km\\n (landlocked)&quot; 0 ## 4 Austria &quot;0 km\\n (landlocked)&quot; 0 ## 5 Azerbaijan &quot;0 km\\n (landlocked);… 0 ## 6 Belarus &quot;0 km\\n (landlocked)&quot; 0 ## 7 Bhutan &quot;0 km\\n (landlocked)&quot; 0 ## 8 Bolivia &quot;0 km\\n (landlocked)&quot; 0 ## 9 Botswana &quot;0 km\\n (landlocked)&quot; 0 ## 10 Burkina F… &quot;0 km\\n (landlocked)&quot; 0 ## # … with 256 more rows und schließlich absteigend, sodass die größten Werte an erster Stelle stehen. coast %&gt;% arrange(desc(coast_num)) ## # A tibble: 266 x 3 ## Country Coastline coast_num ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 World &quot;356,000 km\\n \\n … 356000 ## 2 Canada &quot;202,080 km\\n \\n … 202080 ## 3 Pacific Oc… &quot;135,663 km&quot; 135663 ## 4 Atlantic O… &quot;111,866 km&quot; 111866 ## 5 Indian Oce… &quot;66,526 km&quot; 66526 ## 6 European U… &quot;65,992.9 km&quot; 65993. ## 7 Indonesia &quot;54,716 km&quot; 54716 ## 8 Arctic Oce… &quot;45,389 km&quot; 45389 ## 9 Greenland &quot;44,087 km&quot; 44087 ## 10 Russia &quot;37,653 km&quot; 37653 ## # … with 256 more rows Bevor wir jedoch eine vollständig sortierte Liste haben, muss der Datensatz noch von falschen Einträgen gesäubert werden. Dafür benutzen wir den Befehl filter(). Wir suchen wieder nach einem bestimmten Muster (hier zum Beispiel dem Wort Ocean) und filtern es aus dem Datensatz. Die Grafik soll nur aus den ersten 30 Einträgen der Tabelle bestehen, welche uns der Befehl head() ausgibt. coast %&gt;% arrange(desc(coast_num)) %&gt;% filter(!str_detect(Country, &quot;Ocean&quot;)) %&gt;% filter(!Country %in% c(&quot;World&quot;, &quot;European Union&quot;)) %&gt;% head(30) -&gt; top_30 10.6 Datenvisualisierung Das Balkendiagramm erhalten wir durch den ggplot Befehl. Hierbei gibt es verschiedenste Einstellmöglichkeiten. Wichitg sind vor allem die Angabe des verwendeten Datensatzes und die Art der Grafik (ob Kartendarstellung oder Balkendiagramm). Desweiteren kann man noch Farben der Eigenschaften, eine Achsenbeschriftung u. v. m. bestimmen. ggplot(top_30, aes(x = reorder(Country, coast_num), y=coast_num)) + geom_bar(stat=&#39;identity&#39;, fill=&quot;darkblue&quot;) + coord_flip() + scale_x_discrete(NULL) + scale_y_continuous(&quot;Küstenlinie (km)&quot;) 10.7 Aufgaben Importieren Sie die Daten zu den tödlichen Erdbeben auf Wikipedia und formen sie diese zu einem tibble um. &quot;https://en.wikipedia.org/wiki/List_of_deadly_earthquakes_since_1900&quot; %&gt;% read_html %&gt;% html_table(fill = T) %&gt;% .[[5]] %&gt;% as.tibble() -&gt; earthquakes_raw Erstellen Sie mit den erhaltenen Daten eine Karte, welche die Lage und die Stärke der Erdbeben angibt: earthquakes_raw %&gt;% mutate(Lat = as.numeric(Lat), Long = as.numeric(Long)) %&gt;% mutate(magnitude_num = as.numeric(str_extract(Magnitude, &quot;[0-9.]+&quot;))) -&gt; earthquakes ggplot() + geom_polygon(data = map_data(&quot;world&quot;), aes(x = long, y = lat, group = group)) + geom_point(data = earthquakes, aes(x = Long, y = Lat, size = magnitude_num), color = &quot;red&quot;, alpha = 0.1) + coord_quickmap() + scale_size_area(&quot;Stärke&quot;) Wandeln Sie den Erdbeben-Datensatz in das Simple Features Format um. Laden Sie zusätzlich eine Weltkarte mit dem Paket rnaturalearth und wandeln Sie auch diese in Simple Features um. Finden Sie außerdem einen Geodatensatz zu tektonischen Platten. Visualiseren Sie alles auf einer Welktarte (Projektion: Gall-Peters). library(sf) earthquakes %&gt;% filter(! is.na(Long)) %&gt;% st_as_sf(coords=c(&quot;Long&quot;, &quot;Lat&quot;)) %&gt;% st_set_crs(4326) -&gt; quakesf library(rnaturalearth) ne_download(type=&quot;land&quot;, category = &quot;physical&quot;) %&gt;% st_as_sf() %&gt;% st_transform(&#39;+proj=cea +lon_0=0 +x_0=0 +y_0=0 +lat_ts=45 +ellps=WGS84 +datum=WGS84 +units=m +no_defs&#39;) -&gt; earthsf st_read(&quot;https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_plates.json&quot;) -&gt; plates ggplot() + geom_sf(data = earthsf, fill = &quot;gray&quot;, color = NA) + geom_sf(size = 1, data = quakesf, color = &quot;red&quot;, alpha = 0.1) + geom_sf(data = plates, color = &quot;orange&quot;, fill = NA, lwd = 0.3) "],["web-scraping.html", "Sitzung 11 Web scraping 11.1 Lernziele dieser Sitzung 11.2 Vorbereitung 11.3 Exkurs: HTML 11.4 Seite laden 11.5 Elemente suchen 11.6 Elemente reinigen 11.7 Aufgaben", " Sitzung 11 Web scraping 11.1 Lernziele dieser Sitzung Sie können… HTML in seiner Grundstruktur interpretieren. gezielt einzelne Elemente einer Seite mit R auslesen. 11.2 Vorbereitung Für diese Lektion werden folgende Pakete benötigt: library(tidyverse) library(rvest) 11.3 Exkurs: HTML Wenn man eine Webseite ganz normal in einem Browser aufruft, erscheint sie als eine Mischung aus formatiertem Text, Bildern, Designelementen, ggf. Videos, usw. Was aber im Hintergrund eigentlich vom Server an den Browser übertragen wird, ist eine Textdatei in einem bestimmten Format – HTML (Hyptertext Markup Language). Darin wird Text auf eine genau festgelegte Art und Weise annotiert, damit der Browser weiß, wie er ihn anzeigen soll. Im HTML-Dokument kann auch stehen: Lade ein Bild von einer bestimmten Stelle und zeig es an dieser Stelle an. Einen brauchbaren Überblick über die HTML-Elemente und die Struktur einer HTML-Datei gibt es hier: https://www.tutorialspoint.com/de/html/ An dieser Stelle ist wichtig ist zu wissen: HTML-Elemente (Tags oder Nodes) sind streng hierarchisch angeordnet. Sie bestehen oft aus einem Anfangs- und einem End-Tag in spitzen Klammern: &lt;html&gt; &lt;head&gt; &lt;title&gt;Titel meiner Webseite&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Überschrift&lt;/h1&gt; &lt;p&gt;Erster Absatz mit &lt;b&gt;fettem Text&lt;/b&gt;&lt;/p&gt; &lt;p&gt;Zweiter Absatz mit &lt;i&gt;kursivem Text&lt;/i&gt;&lt;/p&gt; &lt;img src=&quot;path/to/image.jpg alt=&quot;Ein Bild&quot; /&gt; &lt;/body&gt; &lt;/html&gt; In diesem Beispiel ist das Bild mit &lt;img /&gt; das einzige Element, das nicht geöffnet und wieder geschlossen wird. Außerdem hat dieses Element Attribute (src und alt) mit bestimmten Werten. Eine echte Webseite ist weitaus komplexer und unübersichtlicher. Dem Browser kann man sagen: Zeig mir nicht wie üblich die „gerenderte“ Seite an, sondern die zu Grunde liegende HTML-Datei. Das geht mit „Quelltext anzeigen“ / „View Source“ o.ä. Viele Browser (hier seien Chrome und Firefox empfohlen) haben auch einen Modus namens „Entwicklertools“ / „Developer tools“, in dem die HTML-Elemente hierarchisch geordnet sind. 11.4 Seite laden Beim so genannten Web Scraping ist die Grundidee, dass wir eine Webseite nicht im Browser öffnen, sondern den HTML-Quelltext direkt in R laden. R kann dann aus dem Quelltext bestimmte Elemente extrahieren. In der letzten Sitzung haben wir schon gesehen, wie Tabellen nach genau diesem Prinzip von einer Webseite direkt in R geladen werden können. Jetzt soll es darum gehen, noch präziser zu sagen, welche Elemente wir von einer bestimmten Webseite ziehen wollen. Als Beispiel soll die Infoseite eines Wohnheims des Studentenwerks Frankfurt dienen. Die Adresse ist: https://www.studentenwerkfrankfurt.de/wohnen/wohnheime/frankfurt-am-main/kleine-seestrasse-11 Zunächst laden wir den Quelltext in R und nennen ihn quelltext: quelltext &lt;- read_html(&quot;https://www.studentenwerkfrankfurt.de/wohnen/wohnheime/frankfurt-am-main/kleine-seestrasse-11&quot;) quelltext ## {html_document} ## &lt;html lang=&quot;de&quot; dir=&quot;ltr&quot; class=&quot;no-js&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content= ... ## [2] &lt;body id=&quot;p187&quot; class=&quot;page-187 pagelevel-4 lang ... In diesem Schritt hat R den HTML-Quelltext schon geparsed, d.h. ihn nicht nur als Text gespeichert, sondern als hierarchische Konstruktion mit den beiden Grundelementen head und html. 11.5 Elemente suchen Uns soll jetzt das Baujahr interessieren. Auf der Seite stehen die Informationen rechts neben dem Bild. Mit den Entwicklertools können wir schauen, wie die Elemente in HTML genau heißen. Ein geeigneter Ausgangspunkt wäre das &lt;div&gt;-Element mit dem Attribut id=\"c599\". In R können wir dieses einzelne Element ansprechen mit: quelltext %&gt;% html_node(&quot;div#c599&quot;) ## {html_node} ## &lt;div id=&quot;c599&quot; class=&quot;frame frame-default frame-type-text frame-layout-0 frame-background-none frame-no-backgroundimage frame-space-before-none frame-space-after-none&quot;&gt; ## [1] &lt;div class=&quot;frame-container&quot;&gt;&lt;div class=&quot;frame-i ... Dann gehen wir in der Hierarchie drei &lt;div&gt;- Elemente „tiefer“. (&lt;div&gt;- Elemente sind abstrakte Container und werden im Webdesign oft angewendet.) quelltext %&gt;% html_node(&quot;div#c599&quot;) %&gt;% html_node(&quot;div&quot;) %&gt;% html_node(&quot;div&quot;) ## {html_node} ## &lt;div class=&quot;frame-inner&quot;&gt; ## [1] &lt;p&gt;Kleine Seestraße 11&lt;br&gt;60486 Frankfurt am Mai ... ## [2] &lt;p&gt;25 Wohnheimplätze&lt;/p&gt;\\n ## [3] &lt;ul class=&quot;list-normal&quot;&gt;\\n&lt;li&gt;5 Wohnküchen&lt;/li&gt;\\ ... ## [4] &lt;p&gt;Baujahr&lt;strong&gt; &lt;/strong&gt;1995\\r&lt;/p&gt;\\n ## [5] &lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt; Alternativ könnten wir auch sagen: Darin das div mit class=\"frame-inner\": quelltext %&gt;% html_node(&quot;div#c599&quot;) %&gt;% html_node(&quot;div.frame-inner&quot;) ## {html_node} ## &lt;div class=&quot;frame-inner&quot;&gt; ## [1] &lt;p&gt;Kleine Seestraße 11&lt;br&gt;60486 Frankfurt am Mai ... ## [2] &lt;p&gt;25 Wohnheimplätze&lt;/p&gt;\\n ## [3] &lt;ul class=&quot;list-normal&quot;&gt;\\n&lt;li&gt;5 Wohnküchen&lt;/li&gt;\\ ... ## [4] &lt;p&gt;Baujahr&lt;strong&gt; &lt;/strong&gt;1995\\r&lt;/p&gt;\\n ## [5] &lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt; mit html_nodes() (Mehrzahl) werden alle Unterelemente eines Typs (hier &lt;p&gt; = Paragraph) angesprochen. Davon dann den Textinhalt (html_text()) gibt uns die relevanten Informationen: quelltext %&gt;% html_node(&quot;div#c599&quot;) %&gt;% html_node(&quot;div.frame-inner&quot;) %&gt;% html_nodes(&quot;p&quot;) %&gt;% html_text() ## [1] &quot;Kleine Seestraße 1160486 Frankfurt am Main\\r&quot; ## [2] &quot;25 Wohnheimplätze&quot; ## [3] &quot;Baujahr 1995\\r&quot; ## [4] &quot;&quot; 11.6 Elemente reinigen Jetzt ließe sich der dritte Eintrag dieses Ergebnisvectors reinigen und als Ergebnis speichern. Der Befehl str_extract() wendet dabei einen Regulären Ausdruck an, der nach einer Folge von vier Zahlen sucht. quelltext %&gt;% html_node(&quot;div#c599&quot;) %&gt;% html_node(&quot;div.frame-inner&quot;) %&gt;% html_nodes(&quot;p&quot;) %&gt;% html_text() %&gt;% .[3] %&gt;% str_extract(&quot;[0-9]{4}&quot;) %&gt;% as.numeric() -&gt; baujahr baujahr ## [1] 1995 Wie diese Technik automatisiert auf eine Reihe von Seiten angewendet werden kann, wird zu einem späteren Zeitpunkt besprochen. 11.7 Aufgaben Lesen Sie die Anzahl der Wohnheimplätze aus. quelltext ## {html_document} ## &lt;html lang=&quot;de&quot; dir=&quot;ltr&quot; class=&quot;no-js&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content= ... ## [2] &lt;body id=&quot;p187&quot; class=&quot;page-187 pagelevel-4 lang ... quelltext %&gt;% html_node(&quot;div#c599&quot;) %&gt;% html_node(&quot;div.frame-inner&quot;) %&gt;% html_nodes(&quot;p&quot;) %&gt;% html_text() %&gt;% .[2] %&gt;% str_extract(&quot;[0-9]+&quot;) %&gt;% as.numeric() -&gt; anzahl_plaetze anzahl_plaetze ## [1] 25 Lesen Sie Baujahr und Anzahl der Wohnheimplätze von einem anderen Wohnheim aus. Was muss angepasst werden? # z.B.: https://www.studentenwerkfrankfurt.de/wohnen/wohnheime/wiesbaden/max-kade-haus-adolfsallee-49-53 &quot;https://www.studentenwerkfrankfurt.de/wohnen/wohnheime/wiesbaden/max-kade-haus-adolfsallee-49-53&quot; %&gt;% read_html() -&gt; quelltext_wi # Baujahr nicht vorhanden! baujahr_wi &lt;- NA quelltext_wi %&gt;% html_node(&quot;div#c1563&quot;) %&gt;% # Auf dieser Seite ist es eine andere div-ID! # Außerdem: Appartment = Platz? Scheint aber so zu sein... html_node(&quot;div.frame-inner&quot;) %&gt;% html_nodes(&quot;p&quot;) %&gt;% html_text() %&gt;% .[2] %&gt;% str_extract(&quot;[0-9]+&quot;) %&gt;% as.numeric() -&gt; anzahl_plaetze_wi anzahl_plaetze_wi ## [1] 87 Ändern Sie das Script so, dass es auf beiden (allen) Wohnheimseiten funktioniert. # Hier kann (hoffentlich) auch jede andere Wohnheim-URL eingesetzt werden. &quot;https://www.studentenwerkfrankfurt.de/wohnen/wohnheime/frankfurt-am-main/kleine-seestrasse-11&quot; %&gt;% read_html() -&gt; quelltext_x quelltext_x %&gt;% # So funktioniert es unabhänging von ID: html_node(&quot;div.wohnheim-2 &gt; div:nth-child(2)&quot;) %&gt;% html_nodes(&quot;p&quot;) %&gt;% html_text() -&gt; items items[3] %&gt;% str_extract(&quot;[0-9]{4}&quot;) %&gt;% as.numeric() -&gt; baujahr_x items[2] %&gt;% # Funktioniert leider nicht bei der getrennten Angabe mehrerer Kategorien: str_extract(&quot;[0-9]+&quot;) %&gt;% as.numeric() -&gt; anzahl_plaetze_x Lesen Sie die Adresse eines Wohnheims aus. Speichern Sie dabei Straße, Hausnummer, Postleitzahl und Ort getrennt. # Wie in Aufgabe 5 ersichtlich lassen sich die beiden Adresszeilen eigentlich # recht einfach aus der Übersichtsseite auslesen. # Eine Schwierigkeit beim Auslesen aus der Einzelseite liegt darin, dass die # Funktion html_text() den Zeilenumbruch &lt;br&gt; &quot;verschluckt&quot;. Die neueste Version # von rvest beinhaltet die Funktion html_text2(), die genau dieses Probem löst. # Die neue Version kann installiert werden mit: # install.packages(&quot;devtools&quot;) # devtools::install_github(&quot;tidyverse/rvest&quot;) # (Danach R neu starten) quelltext_x %&gt;% html_node(&quot;div.wohnheim-2 &gt; div:nth-child(2)&quot;) %&gt;% html_nodes(&quot;p&quot;) %&gt;% html_text2() %&gt;% .[1] %&gt;% trimws() %&gt;% str_split(&quot;\\n&quot;) %&gt;% .[[1]] -&gt; adresse # Die Hausnummer sind die Zahlen am Ende der ersten Zeile: adresse[1] %&gt;% str_extract(&quot;[-0-9]+$&quot;) -&gt; hausnummer # Funktioniert aber nicht bei 1b u.ä... # Die Straße ist der Rest: adresse[1] %&gt;% str_remove(&quot; [0-9]+$&quot;) -&gt; strasse # Die PLZ sind die 5 Zahlen am Anfang der zweiten Zeile: adresse[2] %&gt;% str_extract(&quot;^[0-9]{5}&quot;) -&gt; plz # Der Ort ist der Rest: adresse[2] %&gt;% str_remove(&quot;^[0-9]{5} &quot;) -&gt; ort Sammeln Sie eine Liste aller Wohnheime mit Link. &quot;https://www.studentenwerkfrankfurt.de/wohnen/wohnheime&quot; %&gt;% read_html() %&gt;% html_nodes(&quot;div.thumbnail&quot;) -&gt; items items %&gt;% html_node(&quot;a&quot;) %&gt;% html_attr(&quot;href&quot;) -&gt; links items %&gt;% html_node(&quot;h4&quot;) %&gt;% html_text -&gt; strasse_nr items %&gt;% html_node(&quot;p&quot;) %&gt;% html_text() -&gt; plz_ort tibble(links, strasse_nr, plz_ort) -&gt; index Sammeln Sie einen Datensatz (tibble) aller Nutzungsentgelte mit Wohnheim, Baujahr, Anzahl Wohneinheiten und Adresse. Stellen Sie sich vor, es handelte sich um Tausende Wohnheime – vermeiden Sie also Copy-Paste-Strategien. # Hierfür gibt es einige Strategien. Meine präferierte Variante erfordert # zunächst eine eigene Funktion, die eine URL nimmt und die gewünschten # Informationen ausgibt: scrape &lt;- function(url) { url %&gt;% read_html -&gt; quelltext quelltext %&gt;% html_table() %&gt;% last() %&gt;% # Die Größe soll immer ein String sein, weil es sonst später Probeme gibt: mutate(`Größe m²` = as.character(`Größe m²`)) -&gt; Nutzungsentgelte quelltext %&gt;% html_node(&quot;div.wohnheim-2 &gt; div:nth-child(2)&quot;) %&gt;% html_nodes(&quot;p&quot;) -&gt; items items[[1]] %&gt;% html_text2() %&gt;% trimws() %&gt;% str_split(&quot;\\n&quot;) %&gt;% .[[1]] -&gt; adresse Nutzungsentgelte$strasse &lt;- adresse[1] Nutzungsentgelte$ort &lt;- adresse[2] items[3] %&gt;% html_text() %&gt;% str_extract(&quot;[0-9]{4}&quot;) %&gt;% as.numeric() -&gt; Nutzungsentgelte$baujahr items[2] %&gt;% html_text() %&gt;% str_extract(&quot;[0-9]+&quot;) %&gt;% as.numeric() -&gt; Nutzungsentgelte$anzahl_plaetze return(Nutzungsentgelte) } # Dann kann ich die eigene Funktion &quot;scrape&quot; auf alle Links anwenden. Das # Ergebnis ist eine Liste von Tibbles. Die lässt sich schließlich noch # kombinieren: index$links %&gt;% paste0(&quot;https://www.studentenwerkfrankfurt.de&quot;, .) %&gt;% map(scrape) %&gt;% do.call(bind_rows, .) -&gt; liste liste ## # A tibble: 133 x 8 ## Art `Größe m²` Ausstattung `EUR*` strasse ort ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;Ein… &quot;16&quot; &quot;unmöblier… &quot;250,… Beetho… 6032… ## 2 &quot;Ein… &quot;18-20&quot; &quot;unmöblier… &quot;311,… Beetho… 6032… ## 3 &quot;Ein… &quot;24&quot; &quot;barrieref… &quot;295,… Beetho… 6032… ## 4 &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Beetho… 6032… ## 5 &quot;Ein… &quot;9&quot; &quot;möbliert,… &quot;207,… Bocken… 6032… ## 6 &quot;Ein… &quot;15&quot; &quot;unmöblier… &quot;236,… Bocken… 6032… ## 7 &quot;Zwe… &quot;45&quot; &quot;unmöblier… &quot;Bele… Bocken… 6032… ## 8 &quot;Ein… &quot;11 - 17&quot; &quot;unmöblier… &quot;256,… Fröbel… 6048… ## 9 &quot;Ein… &quot;11&quot; &quot;möbliert,… &quot;266,… Fröbel… 6048… ## 10 &quot;Ein… &quot;23&quot; &quot;unmöblier… &quot;315,… Fröbel… 6048… ## # … with 123 more rows, and 2 more variables: ## # baujahr &lt;dbl&gt;, anzahl_plaetze &lt;dbl&gt; "],["text-straube-2021.html", "Sitzung 12 Text: Straube 2021 12.1 Lesetexte 12.2 Fragen an den Text", " Sitzung 12 Text: Straube 2021 12.1 Lesetexte Straube, Till. 2021. Datenbeschaffung. In: Tabea Bork-Hüffer, Henning Füller und Till Straube (Hrsg). Handbuch Digitale Geographien. Stuttgart: UTB. Bauß, Jan-Luca und Felix Hiemeyer. 2021. Research Puzzle: Datenbeschaffung durch Web Scraping. In: Tabea Bork-Hüffer, Henning Füller und Till Straube (Hrsg). Handbuch Digitale Geographien. Stuttgart: UTB. 12.2 Fragen an den Text Um was für eine Art von Text handelt es sich? An wen wenden sich die Autoren? Welche Momente werden im Research Puzzle beschrieben, in denen die Autoren ihr Vorhaben geändert haben? Wie verändert Datenbeschaffung (statt -erhebung) den wissenschaftlichen Prozess? Welche Beispiele gibt es im Rahmen Ihres Projektvorhabens für… offene Daten? Daten, die sich durch web scraping abrufen lassen? Daten, die sich über (öffentliche oder private) APIs abrufen lassen? "],["apis.html", "Sitzung 13 APIs 13.1 Vorbereitung 13.2 SWAPI 13.3 Exkurs: Funktionen schreiben 13.4 Abfragefunktion", " Sitzung 13 APIs 13.1 Vorbereitung Für diese Lektion werden die Pakete benötigt: library(tidyverse) library(jsonlite) 13.2 SWAPI Die Star Wars API ist eine eigens für Übungszwecke eingerichtete API, und steht uns deshalb (anders als andere APIs) ohne Login zur Verfügung. Wir sollten bei der Benutzung darauf achten, sie nicht zu überladen. Jede gute API kommt mit einer ausführlichen Dokumentation in der die Endpunkte und Abfrageoptionen erklärt sind. Bei den hier besprochenen REST-APIs geht es eigentlich nur darum, die richtige Abfrage als URL zu formulieren. Die Antwort des Servers gibt uns dann die Daten, die wir brauchen, und zwar üblicherweise im JSON-Format. Zum Beispiel fragen wir so Informationen über Han Solo ab: han_solo &lt;- read_json(&quot;https://www.swapi.tech/api/people/14/&quot;)$result Die Antwort ist eine Liste, deren Elemente sich wie gewohnt mit $ ansprechen lassen und wiederum Hinweise auf API-Abfragen enthalten können: han_solo$properties$eye_color ## [1] &quot;brown&quot; han_solo$properties$homeworld ## [1] &quot;https://www.swapi.tech/api/planets/22&quot; Diese Information ließe sich wiederum abfragen durch: han_solo$properties$homeworld %&gt;% read_json() %&gt;% .$result %&gt;% .$properties %&gt;% .$name ## [1] &quot;Corellia&quot; Eine (recht willkürlich gewählte) Herausforderung wäre es nun, die Namen aller Charaktere herauszufinden, die in Return of the Jedi vorkommen. Zunächst können wir den richtigen Film suchen mit: read_json(&quot;https://www.swapi.tech/api/films/&quot;)$result %&gt;% map(&quot;properties&quot;) %&gt;% map(&quot;title&quot;) ## [[1]] ## [1] &quot;A New Hope&quot; ## ## [[2]] ## [1] &quot;The Empire Strikes Back&quot; ## ## [[3]] ## [1] &quot;Return of the Jedi&quot; ## ## [[4]] ## [1] &quot;The Phantom Menace&quot; ## ## [[5]] ## [1] &quot;Attack of the Clones&quot; ## ## [[6]] ## [1] &quot;Revenge of the Sith&quot; Dann lässt sich die gewünschte Liste ziehen mit: read_json(&quot;https://www.swapi.tech/api/films/3&quot;)$result$properties$characters -&gt; return_characters Für jeden dieser Charaktere ließe sich der Name herausfinden mit read_json(&quot;https://www.swapi.tech/api/people/1/&quot;)$result$properties$name ## [1] &quot;Luke Skywalker&quot; read_json(&quot;https://www.swapi.tech/api/people/4/&quot;)$result$properties$name ## [1] &quot;Darth Vader&quot; # usw. Können wir aber auch die Namen nicht einzeln, sondern automatisch Abfragen? 13.3 Exkurs: Funktionen schreiben Funktionen sind überall in R. Funktionen haben eine Eingabe (parameters) und eine Ausgabe (return values). Z.B. hat die Funktion mean() als Eingabe einen numerischen Vektor, und als Ausgabe das arithmetische Mittel dieses Vektors: data(diamonds) mean(diamonds$carat) ## [1] 0.7979397 Wir können auch eigene Funktionen schreiben. Die Definition einer eigenen Funktionen hat immer diese Form: FUNKTIONSNAME &lt;- function(EINGABE) { ... AUSGABE } Wenn es die Funktion mean() nicht gäbe, könnten wir sie (bzw. so etwas ähnliches) selbst schreiben, mit: my_mean &lt;- function(verteilung) { sum(verteilung) / length(verteilung) } Wenn wir die Definition ausführen, erscheint die Funktion in unserem Environment, genauso wie andere Objekte. Wir können sie dann genauso anwenden wie andere Funktionen: my_mean(diamonds$carat) ## [1] 0.7979397 my_mean(diamonds$depth) ## [1] 61.7494 13.4 Abfragefunktion Eine Funktion zur automatischen Abfrage der Charakternamen bräuchte als Eingabe die URL der API, und als Ausgabe den Charakternamen. Eigentlich geht es nur um eine Abstraktion des konkreten Befehls: read_json(&quot;https://www.swapi.tech/api/people/1/&quot;)$result$properties$name ## [1] &quot;Luke Skywalker&quot; Die Definition der Funktion könnte so aussehen: get_character_name &lt;- function(url) { read_json(url)$result$properties$name } Testweise lässt sie sich anwenden: get_character_name(&quot;https://www.swapi.tech/api/people/1/&quot;) ## [1] &quot;Luke Skywalker&quot; Leider lässt sie sich nicht so einfach (wie andere Funktionen) auf den Vektor von URLS anwenden, da die Funktion keinen Vektor als Eingabe erwartet: Abhilfe schafft der Befehl map() aus dem purrr-Paket (Teil von tidyverse). Hier lässt sich ein Vektor (oder eine Liste) angeben, sowie der Name einer Funktion, die dann auf jedes Element des Vektors angewendet wird: map(return_characters, get_character_name) Resultat ist eine Liste, die sich mit unlist() auch zu einem Vektor wandeln ließe… oder man benutzt direkt die Abwandlung map_chr(), die nach Möglichkeit immer einen character vector ausgibt: map_chr(return_characters, get_character_name) ## [1] &quot;Luke Skywalker&quot; &quot;C-3PO&quot; ## [3] &quot;R2-D2&quot; &quot;Darth Vader&quot; ## [5] &quot;Leia Organa&quot; &quot;Obi-Wan Kenobi&quot; ## [7] &quot;Chewbacca&quot; &quot;Han Solo&quot; ## [9] &quot;Jabba Desilijic Tiure&quot; &quot;Wedge Antilles&quot; ## [11] &quot;Yoda&quot; &quot;Palpatine&quot; ## [13] &quot;Boba Fett&quot; &quot;Lando Calrissian&quot; ## [15] &quot;Ackbar&quot; &quot;Mon Mothma&quot; ## [17] &quot;Arvel Crynyd&quot; &quot;Wicket Systri Warrick&quot; ## [19] &quot;Nien Nunb&quot; &quot;Bib Fortuna&quot; "]]
